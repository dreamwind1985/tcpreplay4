/*   -*- buffer-read-only: t -*- vi: set ro:
 *  
 *  DO NOT EDIT THIS FILE   (tcpprep_opts.c)
 *  
 *  It has been AutoGen-ed  December 17, 2014 at 03:12:34 PM by AutoGen 5.16.2
 *  From the definitions    tcpprep_opts.def
 *  and the template file   options
 *
 * Generated from AutoOpts 36:5:11 templates.
 *
 *  AutoOpts is a copyrighted work.  This source file is not encumbered
 *  by AutoOpts licensing, but is provided under the licensing terms chosen
 *  by the tcpprep author or copyright holder.  AutoOpts is
 *  licensed under the terms of the LGPL.  The redistributable library
 *  (``libopts'') is licensed under the terms of either the LGPL or, at the
 *  users discretion, the BSD license.  See the AutoOpts and/or libopts sources
 *  for details.
 *
 * The tcpprep program is copyrighted and licensed
 * under the following terms:
 *
 *  Copyright (C) 2000-2014 Aaron Turner and Fred Klassen, all rights reserved.
 *  This is free software. It is licensed for use, modification and
 *  redistribution under the terms of the
 *  GNU General Public License, version 3 or later
 *      <http://gnu.org/licenses/gpl.html>
 *
 *  tcpprep is free software: you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by the
 *  Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *  
 *  tcpprep is distributed in the hope that it will be useful, but
 *  WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 *  See the GNU General Public License for more details.
 *  
 *  You should have received a copy of the GNU General Public License along
 *  with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#ifndef __doxygen__
#define OPTION_CODE_COMPILE 1
#include "tcpprep_opts.h"
#include <sys/types.h>

#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>

#ifdef  __cplusplus
extern "C" {
#endif
extern FILE * option_usage_fp;

/* TRANSLATORS: choose the translation for option names wisely because you
                cannot ever change your mind. */
#define zCopyright      (tcpprep_opt_strs+0)
#define zLicenseDescrip (tcpprep_opt_strs+283)

/*
 *  global included definitions
 */
#include "defines.h"
#include "common.h"
#include "config.h"
#include "tcpprep.h"
#include <stdlib.h>
#include <string.h>
#include "tcpprep_api.h"
extern tcpprep_t *tcpprep;


#ifndef NULL
#  define NULL 0
#endif

/*
 *  tcpprep option static const strings
 */
static char const tcpprep_opt_strs[3088] =
/*     0 */ "tcpprep (tcpprep)\n"
            "Copyright (C) 2000-2014 Aaron Turner and Fred Klassen, all rights reserved.\n"
            "This is free software. It is licensed for use, modification and\n"
            "redistribution under the terms of the\n"
            "GNU General Public License, version 3 or later\n"
            "    <http://gnu.org/licenses/gpl.html>\n\0"
/*   283 */ "tcpprep is free software: you can redistribute it and/or modify it under\n"
            "the terms of the GNU General Public License as published by the Free\n"
            "Software Foundation, either version 3 of the License, or (at your option)\n"
            "any later version.\n\n"
            "tcpprep is distributed in the hope that it will be useful, but WITHOUT ANY\n"
            "WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n"
            "FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n"
            "details.\n\n"
            "You should have received a copy of the GNU General Public License along\n"
            "with this program.  If not, see <http://www.gnu.org/licenses/>.\n\0"
/*   886 */ "Enable debugging output\0"
/*   910 */ "DBUG\0"
/*   915 */ "dbug\0"
/*   920 */ "Auto-split mode\0"
/*   936 */ "AUTO\0"
/*   941 */ "auto\0"
/*   946 */ "CIDR-split mode\0"
/*   962 */ "CIDR\0"
/*   967 */ "cidr\0"
/*   972 */ "Regex-split mode\0"
/*   989 */ "REGEX\0"
/*   995 */ "regex\0"
/*  1001 */ "Port-split mode\0"
/*  1017 */ "PORT\0"
/*  1022 */ "port\0"
/*  1027 */ "Source MAC split mode\0"
/*  1049 */ "MAC\0"
/*  1053 */ "mac\0"
/*  1057 */ "Matches to be client instead of server\0"
/*  1096 */ "REVERSE\0"
/*  1104 */ "reverse\0"
/*  1112 */ "Embeded cache file comment\0"
/*  1139 */ "COMMENT\0"
/*  1147 */ "comment\0"
/*  1155 */ "Do not embed any cache file comment\0"
/*  1191 */ "NO_ARG_COMMENT\0"
/*  1206 */ "no-arg-comment\0"
/*  1221 */ "Include only packets matching rule\0"
/*  1256 */ "INCLUDE\0"
/*  1264 */ "include\0"
/*  1272 */ "Exclude any packet matching this rule\0"
/*  1310 */ "EXCLUDE\0"
/*  1318 */ "exclude\0"
/*  1326 */ "Output cache file\0"
/*  1344 */ "CACHEFILE\0"
/*  1354 */ "cachefile\0"
/*  1364 */ "Input pcap file to process\0"
/*  1391 */ "PCAP\0"
/*  1396 */ "pcap\0"
/*  1401 */ "Print embedded comment in the specified cache file\0"
/*  1452 */ "PRINT_COMMENT\0"
/*  1466 */ "print-comment\0"
/*  1480 */ "Print basic info from the specified cache file\0"
/*  1527 */ "PRINT_INFO\0"
/*  1538 */ "print-info\0"
/*  1549 */ "Print statistical information about the specified cache file\0"
/*  1610 */ "PRINT_STATS\0"
/*  1622 */ "print-stats\0"
/*  1634 */ "Load services file for server ports\0"
/*  1670 */ "SERVICES\0"
/*  1679 */ "services\0"
/*  1688 */ "Send non-IP traffic out server interface\0"
/*  1729 */ "NONIP\0"
/*  1735 */ "nonip\0"
/*  1741 */ "Ratio of client to server packets\0"
/*  1775 */ "RATIO\0"
/*  1781 */ "ratio\0"
/*  1787 */ "2.0\0"
/*  1791 */ "Minimum network mask length in auto mode\0"
/*  1832 */ "MINMASK\0"
/*  1840 */ "minmask\0"
/*  1848 */ "Maximum network mask length in auto mode\0"
/*  1889 */ "MAXMASK\0"
/*  1897 */ "maxmask\0"
/*  1905 */ "Print decoded packets via tcpdump to STDOUT\0"
/*  1949 */ "VERBOSE\0"
/*  1957 */ "verbose\0"
/*  1965 */ "Arguments passed to tcpdump decoder\0"
/*  2001 */ "DECODE\0"
/*  2008 */ "decode\0"
/*  2015 */ "Print version information\0"
/*  2041 */ "VERSION\0"
/*  2049 */ "version\0"
/*  2057 */ "Display less usage information and exit\0"
/*  2097 */ "LESS_HELP\0"
/*  2107 */ "less-help\0"
/*  2117 */ "Display extended usage information and exit\0"
/*  2161 */ "help\0"
/*  2166 */ "Extended usage information passed thru pager\0"
/*  2211 */ "more-help\0"
/*  2221 */ "Save the option state to a config file\0"
/*  2260 */ "save-opts\0"
/*  2270 */ "Load options from a config file\0"
/*  2302 */ "LOAD_OPTS\0"
/*  2312 */ "no-load-opts\0"
/*  2325 */ "no\0"
/*  2328 */ "TCPPREP\0"
/*  2336 */ "tcpprep (tcpprep) - Create a tcpreplay cache cache file from a pcap file.\n"
            "USAGE:  %s [ -<flag> [<val>] | --<name>[{=| }<val>] ]...\n\0"
/*  2468 */ "$$/\0"
/*  2472 */ ".tcppreprc\0"
/*  2483 */ "tcpreplay-users@lists.sourceforge.net\0"
/*  2521 */ "\n"
            "tcpprep is a ``pcap(3)'' file pre-processor which creates a cache file\n"
            "which provides \"rules\" for ``tcprewrite(1)'' and ``tcpreplay(1)'' on how to\n"
            "process and send packets.\n\0"
/*  2696 */ "\n"
            "The basic operation of tcpreplay is to resend all packets from the input\n"
            "file(s) out a single file.  Tcpprep processes a pcap file and applies a set\n"
            "of user-specified rules to create a cache file which tells tcpreplay wether\n"
            "or not to send each packet and which interface the packet should be sent\n"
            "out of.\n\n"
            "For more details, please see the Tcpreplay Manual at:\n"
            "http://tcpreplay.appneta.com\n";

/*
 *  dbug option description:
 */
#ifdef DEBUG
#define DBUG_DESC      (tcpprep_opt_strs+886)
#define DBUG_NAME      (tcpprep_opt_strs+910)
#define DBUG_name      (tcpprep_opt_strs+915)
#define DBUG_DFT_ARG   ((char const*)0)
#define DBUG_FLAGS     (OPTST_DISABLED | OPTST_IMM \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_NUMERIC))

#else   /* disable dbug */
#define DBUG_FLAGS     (OPTST_OMITTED | OPTST_NO_INIT)
#define DBUG_DFT_ARG   NULL
#define DBUG_NAME      NULL
#define DBUG_DESC      NULL
#define DBUG_name      NULL
#endif  /* DEBUG */

/*
 *  auto option description with
 *  "Must also have options" and "Incompatible options":
 */
#define AUTO_DESC      (tcpprep_opt_strs+920)
#define AUTO_NAME      (tcpprep_opt_strs+936)
#define AUTO_name      (tcpprep_opt_strs+941)
static int const aAutoCantList[] = {
    INDEX_OPT_CIDR,
    INDEX_OPT_PORT,
    INDEX_OPT_REGEX,
    INDEX_OPT_MAC, NO_EQUIVALENT };
#define AUTO_FLAGS     (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_STRING))

/*
 *  cidr option description with
 *  "Must also have options" and "Incompatible options":
 */
#define CIDR_DESC      (tcpprep_opt_strs+946)
#define CIDR_NAME      (tcpprep_opt_strs+962)
#define CIDR_name      (tcpprep_opt_strs+967)
static int const aCidrCantList[] = {
    INDEX_OPT_AUTO,
    INDEX_OPT_PORT,
    INDEX_OPT_REGEX,
    INDEX_OPT_MAC, NO_EQUIVALENT };
#define CIDR_FLAGS     (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_STRING))

/*
 *  regex option description with
 *  "Must also have options" and "Incompatible options":
 */
#define REGEX_DESC      (tcpprep_opt_strs+972)
#define REGEX_NAME      (tcpprep_opt_strs+989)
#define REGEX_name      (tcpprep_opt_strs+995)
static int const aRegexCantList[] = {
    INDEX_OPT_AUTO,
    INDEX_OPT_PORT,
    INDEX_OPT_CIDR,
    INDEX_OPT_MAC, NO_EQUIVALENT };
#define REGEX_FLAGS     (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_STRING))

/*
 *  port option description with
 *  "Must also have options" and "Incompatible options":
 */
#define PORT_DESC      (tcpprep_opt_strs+1001)
#define PORT_NAME      (tcpprep_opt_strs+1017)
#define PORT_name      (tcpprep_opt_strs+1022)
static int const aPortCantList[] = {
    INDEX_OPT_AUTO,
    INDEX_OPT_REGEX,
    INDEX_OPT_CIDR,
    INDEX_OPT_MAC, NO_EQUIVALENT };
#define PORT_FLAGS     (OPTST_DISABLED)

/*
 *  mac option description with
 *  "Must also have options" and "Incompatible options":
 */
#define MAC_DESC      (tcpprep_opt_strs+1027)
#define MAC_NAME      (tcpprep_opt_strs+1049)
#define MAC_name      (tcpprep_opt_strs+1053)
static int const aMacCantList[] = {
    INDEX_OPT_AUTO,
    INDEX_OPT_REGEX,
    INDEX_OPT_CIDR,
    INDEX_OPT_PORT, NO_EQUIVALENT };
#define MAC_FLAGS     (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_STRING))

/*
 *  reverse option description:
 */
#define REVERSE_DESC      (tcpprep_opt_strs+1057)
#define REVERSE_NAME      (tcpprep_opt_strs+1096)
#define REVERSE_name      (tcpprep_opt_strs+1104)
#define REVERSE_FLAGS     (OPTST_DISABLED)

/*
 *  comment option description:
 */
#define COMMENT_DESC      (tcpprep_opt_strs+1112)
#define COMMENT_NAME      (tcpprep_opt_strs+1139)
#define COMMENT_name      (tcpprep_opt_strs+1147)
#define COMMENT_FLAGS     (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_STRING))

/*
 *  no-arg-comment option description:
 */
#define NO_ARG_COMMENT_DESC      (tcpprep_opt_strs+1155)
#define NO_ARG_COMMENT_NAME      (tcpprep_opt_strs+1191)
#define NO_ARG_COMMENT_name      (tcpprep_opt_strs+1206)
#define NO_ARG_COMMENT_FLAGS     (OPTST_DISABLED)

/*
 *  include option description with
 *  "Must also have options" and "Incompatible options":
 */
#define INCLUDE_DESC      (tcpprep_opt_strs+1221)
#define INCLUDE_NAME      (tcpprep_opt_strs+1256)
#define INCLUDE_name      (tcpprep_opt_strs+1264)
static int const aIncludeCantList[] = {
    INDEX_OPT_EXCLUDE, NO_EQUIVALENT };
#define INCLUDE_FLAGS     (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_STRING))

/*
 *  exclude option description with
 *  "Must also have options" and "Incompatible options":
 */
#define EXCLUDE_DESC      (tcpprep_opt_strs+1272)
#define EXCLUDE_NAME      (tcpprep_opt_strs+1310)
#define EXCLUDE_name      (tcpprep_opt_strs+1318)
static int const aExcludeCantList[] = {
    INDEX_OPT_INCLUDE, NO_EQUIVALENT };
#define EXCLUDE_FLAGS     (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_STRING))

/*
 *  cachefile option description:
 */
#define CACHEFILE_DESC      (tcpprep_opt_strs+1326)
#define CACHEFILE_NAME      (tcpprep_opt_strs+1344)
#define CACHEFILE_name      (tcpprep_opt_strs+1354)
#define CACHEFILE_FLAGS     (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_STRING))

/*
 *  pcap option description:
 */
#define PCAP_DESC      (tcpprep_opt_strs+1364)
#define PCAP_NAME      (tcpprep_opt_strs+1391)
#define PCAP_name      (tcpprep_opt_strs+1396)
#define PCAP_FLAGS     (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_STRING))

/*
 *  print-comment option description:
 */
#define PRINT_COMMENT_DESC      (tcpprep_opt_strs+1401)
#define PRINT_COMMENT_NAME      (tcpprep_opt_strs+1452)
#define PRINT_COMMENT_name      (tcpprep_opt_strs+1466)
#define PRINT_COMMENT_FLAGS     (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_STRING))

/*
 *  print-info option description:
 */
#define PRINT_INFO_DESC      (tcpprep_opt_strs+1480)
#define PRINT_INFO_NAME      (tcpprep_opt_strs+1527)
#define PRINT_INFO_name      (tcpprep_opt_strs+1538)
#define PRINT_INFO_FLAGS     (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_STRING))

/*
 *  print-stats option description:
 */
#define PRINT_STATS_DESC      (tcpprep_opt_strs+1549)
#define PRINT_STATS_NAME      (tcpprep_opt_strs+1610)
#define PRINT_STATS_name      (tcpprep_opt_strs+1622)
#define PRINT_STATS_FLAGS     (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_STRING))

/*
 *  services option description with
 *  "Must also have options" and "Incompatible options":
 */
#define SERVICES_DESC      (tcpprep_opt_strs+1634)
#define SERVICES_NAME      (tcpprep_opt_strs+1670)
#define SERVICES_name      (tcpprep_opt_strs+1679)
static int const aServicesMustList[] = {
    INDEX_OPT_PORT, NO_EQUIVALENT };
#define SERVICES_FLAGS     (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_STRING))

/*
 *  nonip option description:
 */
#define NONIP_DESC      (tcpprep_opt_strs+1688)
#define NONIP_NAME      (tcpprep_opt_strs+1729)
#define NONIP_name      (tcpprep_opt_strs+1735)
#define NONIP_FLAGS     (OPTST_DISABLED)

/*
 *  ratio option description with
 *  "Must also have options" and "Incompatible options":
 */
#define RATIO_DESC      (tcpprep_opt_strs+1741)
#define RATIO_NAME      (tcpprep_opt_strs+1775)
#define RATIO_name      (tcpprep_opt_strs+1781)
#define RATIO_DFT_ARG   (tcpprep_opt_strs+1787)
static int const aRatioMustList[] = {
    INDEX_OPT_AUTO, NO_EQUIVALENT };
#define RATIO_FLAGS     (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_STRING))

/*
 *  minmask option description with
 *  "Must also have options" and "Incompatible options":
 */
#define MINMASK_DESC      (tcpprep_opt_strs+1791)
#define MINMASK_NAME      (tcpprep_opt_strs+1832)
#define MINMASK_name      (tcpprep_opt_strs+1840)
#define MINMASK_DFT_ARG   ((char const*)30)
static int const aMinmaskMustList[] = {
    INDEX_OPT_AUTO, NO_EQUIVALENT };
#define MINMASK_FLAGS     (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_NUMERIC))

/*
 *  maxmask option description with
 *  "Must also have options" and "Incompatible options":
 */
#define MAXMASK_DESC      (tcpprep_opt_strs+1848)
#define MAXMASK_NAME      (tcpprep_opt_strs+1889)
#define MAXMASK_name      (tcpprep_opt_strs+1897)
#define MAXMASK_DFT_ARG   ((char const*)8)
static int const aMaxmaskMustList[] = {
    INDEX_OPT_AUTO, NO_EQUIVALENT };
#define MAXMASK_FLAGS     (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_NUMERIC))

/*
 *  verbose option description:
 */
#ifdef ENABLE_VERBOSE
#define VERBOSE_DESC      (tcpprep_opt_strs+1905)
#define VERBOSE_NAME      (tcpprep_opt_strs+1949)
#define VERBOSE_name      (tcpprep_opt_strs+1957)
#define VERBOSE_FLAGS     (OPTST_DISABLED | OPTST_IMM)

#else   /* disable verbose */
#define VERBOSE_FLAGS     (OPTST_OMITTED | OPTST_NO_INIT)
#define VERBOSE_NAME      NULL
#define VERBOSE_DESC      NULL
#define VERBOSE_name      NULL
#endif  /* ENABLE_VERBOSE */

/*
 *  decode option description with
 *  "Must also have options" and "Incompatible options":
 */
#ifdef ENABLE_VERBOSE
#define DECODE_DESC      (tcpprep_opt_strs+1965)
#define DECODE_NAME      (tcpprep_opt_strs+2001)
#define DECODE_name      (tcpprep_opt_strs+2008)
static int const aDecodeMustList[] = {
    INDEX_OPT_VERBOSE, NO_EQUIVALENT };
#define DECODE_FLAGS     (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_STRING))

#else   /* disable decode */
#define DECODE_FLAGS     (OPTST_OMITTED | OPTST_NO_INIT)
#define aDecodeMustList   NULL
#define DECODE_NAME      NULL
#define DECODE_DESC      NULL
#define DECODE_name      NULL
#endif  /* ENABLE_VERBOSE */

/*
 *  version option description:
 */
#define VERSION_DESC      (tcpprep_opt_strs+2015)
#define VERSION_NAME      (tcpprep_opt_strs+2041)
#define VERSION_name      (tcpprep_opt_strs+2049)
#define VERSION_FLAGS     (OPTST_DISABLED)

/*
 *  less-help option description:
 */
#define LESS_HELP_DESC      (tcpprep_opt_strs+2057)
#define LESS_HELP_NAME      (tcpprep_opt_strs+2097)
#define LESS_HELP_name      (tcpprep_opt_strs+2107)
#define LESS_HELP_FLAGS     (OPTST_DISABLED | OPTST_IMM)

/*
 *  Help/More_Help option descriptions:
 */
#define HELP_DESC       (tcpprep_opt_strs+2117)
#define HELP_name       (tcpprep_opt_strs+2161)
#ifdef HAVE_WORKING_FORK
#define MORE_HELP_DESC  (tcpprep_opt_strs+2166)
#define MORE_HELP_name  (tcpprep_opt_strs+2211)
#define MORE_HELP_FLAGS (OPTST_IMM | OPTST_NO_INIT)
#else
#define MORE_HELP_DESC  NULL
#define MORE_HELP_name  NULL
#define MORE_HELP_FLAGS (OPTST_OMITTED | OPTST_NO_INIT)
#endif
#define SAVE_OPTS_DESC  (tcpprep_opt_strs+2221)
#define SAVE_OPTS_name  (tcpprep_opt_strs+2260)
#define LOAD_OPTS_DESC     (tcpprep_opt_strs+2270)
#define LOAD_OPTS_NAME     (tcpprep_opt_strs+2302)
#define NO_LOAD_OPTS_name  (tcpprep_opt_strs+2312)
#define LOAD_OPTS_pfx      (tcpprep_opt_strs+2325)
#define LOAD_OPTS_name     (NO_LOAD_OPTS_name + 3)
/*
 *  Declare option callback procedures
 */
#ifdef DEBUG
  static tOptProc doOptDbug;
#else /* not DEBUG */
# define doOptDbug NULL
#endif /* def/not DEBUG */
extern tOptProc
    optionBooleanVal,   optionNestedVal,    optionNumericVal,
    optionPagedUsage,   optionPrintVersion, optionResetOpt,
    optionStackArg,     optionTimeDate,     optionTimeVal,
    optionUnstackArg,   optionVendorOption;
static tOptProc
    doOptAuto,           doOptCidr,           doOptComment,
    doOptExclude,        doOptInclude,        doOptLess_Help,
    doOptMac,            doOptMaxmask,        doOptMinmask,
    doOptNo_Arg_Comment, doOptNonip,          doOptPort,
    doOptRegex,          doOptServices,       doOptVersion,
    doUsageOpt;

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
/**
 *  Define the tcpprep Option Descriptions.
 * This is an array of OPTION_CT entries, one for each
 * option that the tcpprep program responds to.
 */
static tOptDesc optDesc[OPTION_CT] = {
  {  /* entry idx, value */ 0, VALUE_OPT_DBUG,
     /* equiv idx, value */ 0, VALUE_OPT_DBUG,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ DBUG_FLAGS, 0,
     /* last opt argumnt */ { DBUG_DFT_ARG },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ doOptDbug,
     /* desc, NAME, name */ DBUG_DESC, DBUG_NAME, DBUG_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 1, VALUE_OPT_AUTO,
     /* equiv idx, value */ 1, VALUE_OPT_AUTO,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ AUTO_FLAGS, 0,
     /* last opt argumnt */ { NULL }, /* --auto */
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, aAutoCantList,
     /* option proc      */ doOptAuto,
     /* desc, NAME, name */ AUTO_DESC, AUTO_NAME, AUTO_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 2, VALUE_OPT_CIDR,
     /* equiv idx, value */ 2, VALUE_OPT_CIDR,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ CIDR_FLAGS, 0,
     /* last opt argumnt */ { NULL }, /* --cidr */
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, aCidrCantList,
     /* option proc      */ doOptCidr,
     /* desc, NAME, name */ CIDR_DESC, CIDR_NAME, CIDR_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 3, VALUE_OPT_REGEX,
     /* equiv idx, value */ 3, VALUE_OPT_REGEX,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ REGEX_FLAGS, 0,
     /* last opt argumnt */ { NULL }, /* --regex */
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, aRegexCantList,
     /* option proc      */ doOptRegex,
     /* desc, NAME, name */ REGEX_DESC, REGEX_NAME, REGEX_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 4, VALUE_OPT_PORT,
     /* equiv idx, value */ 4, VALUE_OPT_PORT,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ PORT_FLAGS, 0,
     /* last opt argumnt */ { NULL }, /* --port */
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, aPortCantList,
     /* option proc      */ doOptPort,
     /* desc, NAME, name */ PORT_DESC, PORT_NAME, PORT_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 5, VALUE_OPT_MAC,
     /* equiv idx, value */ 5, VALUE_OPT_MAC,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ MAC_FLAGS, 0,
     /* last opt argumnt */ { NULL }, /* --mac */
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, aMacCantList,
     /* option proc      */ doOptMac,
     /* desc, NAME, name */ MAC_DESC, MAC_NAME, MAC_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 6, VALUE_OPT_REVERSE,
     /* equiv idx, value */ 6, VALUE_OPT_REVERSE,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ REVERSE_FLAGS, 0,
     /* last opt argumnt */ { NULL }, /* --reverse */
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ NULL,
     /* desc, NAME, name */ REVERSE_DESC, REVERSE_NAME, REVERSE_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 7, VALUE_OPT_COMMENT,
     /* equiv idx, value */ 7, VALUE_OPT_COMMENT,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ COMMENT_FLAGS, 0,
     /* last opt argumnt */ { NULL }, /* --comment */
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ doOptComment,
     /* desc, NAME, name */ COMMENT_DESC, COMMENT_NAME, COMMENT_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 8, VALUE_OPT_NO_ARG_COMMENT,
     /* equiv idx, value */ 8, VALUE_OPT_NO_ARG_COMMENT,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ NO_ARG_COMMENT_FLAGS, 0,
     /* last opt argumnt */ { NULL }, /* --no-arg-comment */
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ doOptNo_Arg_Comment,
     /* desc, NAME, name */ NO_ARG_COMMENT_DESC, NO_ARG_COMMENT_NAME, NO_ARG_COMMENT_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 9, VALUE_OPT_INCLUDE,
     /* equiv idx, value */ 9, VALUE_OPT_INCLUDE,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ INCLUDE_FLAGS, 0,
     /* last opt argumnt */ { NULL }, /* --include */
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, aIncludeCantList,
     /* option proc      */ doOptInclude,
     /* desc, NAME, name */ INCLUDE_DESC, INCLUDE_NAME, INCLUDE_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 10, VALUE_OPT_EXCLUDE,
     /* equiv idx, value */ 10, VALUE_OPT_EXCLUDE,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ EXCLUDE_FLAGS, 0,
     /* last opt argumnt */ { NULL }, /* --exclude */
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, aExcludeCantList,
     /* option proc      */ doOptExclude,
     /* desc, NAME, name */ EXCLUDE_DESC, EXCLUDE_NAME, EXCLUDE_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 11, VALUE_OPT_CACHEFILE,
     /* equiv idx, value */ 11, VALUE_OPT_CACHEFILE,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ CACHEFILE_FLAGS, 0,
     /* last opt argumnt */ { NULL }, /* --cachefile */
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ NULL,
     /* desc, NAME, name */ CACHEFILE_DESC, CACHEFILE_NAME, CACHEFILE_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 12, VALUE_OPT_PCAP,
     /* equiv idx, value */ 12, VALUE_OPT_PCAP,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ PCAP_FLAGS, 0,
     /* last opt argumnt */ { NULL }, /* --pcap */
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ NULL,
     /* desc, NAME, name */ PCAP_DESC, PCAP_NAME, PCAP_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 13, VALUE_OPT_PRINT_COMMENT,
     /* equiv idx, value */ 13, VALUE_OPT_PRINT_COMMENT,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ PRINT_COMMENT_FLAGS, 0,
     /* last opt argumnt */ { NULL }, /* --print-comment */
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ NULL,
     /* desc, NAME, name */ PRINT_COMMENT_DESC, PRINT_COMMENT_NAME, PRINT_COMMENT_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 14, VALUE_OPT_PRINT_INFO,
     /* equiv idx, value */ 14, VALUE_OPT_PRINT_INFO,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ PRINT_INFO_FLAGS, 0,
     /* last opt argumnt */ { NULL }, /* --print-info */
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ NULL,
     /* desc, NAME, name */ PRINT_INFO_DESC, PRINT_INFO_NAME, PRINT_INFO_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 15, VALUE_OPT_PRINT_STATS,
     /* equiv idx, value */ 15, VALUE_OPT_PRINT_STATS,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ PRINT_STATS_FLAGS, 0,
     /* last opt argumnt */ { NULL }, /* --print-stats */
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ NULL,
     /* desc, NAME, name */ PRINT_STATS_DESC, PRINT_STATS_NAME, PRINT_STATS_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 16, VALUE_OPT_SERVICES,
     /* equiv idx, value */ 16, VALUE_OPT_SERVICES,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ SERVICES_FLAGS, 0,
     /* last opt argumnt */ { NULL }, /* --services */
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ aServicesMustList, NULL,
     /* option proc      */ doOptServices,
     /* desc, NAME, name */ SERVICES_DESC, SERVICES_NAME, SERVICES_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 17, VALUE_OPT_NONIP,
     /* equiv idx, value */ 17, VALUE_OPT_NONIP,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ NONIP_FLAGS, 0,
     /* last opt argumnt */ { NULL }, /* --nonip */
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ doOptNonip,
     /* desc, NAME, name */ NONIP_DESC, NONIP_NAME, NONIP_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 18, VALUE_OPT_RATIO,
     /* equiv idx, value */ 18, VALUE_OPT_RATIO,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ RATIO_FLAGS, 0,
     /* last opt argumnt */ { RATIO_DFT_ARG },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ aRatioMustList, NULL,
     /* option proc      */ NULL,
     /* desc, NAME, name */ RATIO_DESC, RATIO_NAME, RATIO_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 19, VALUE_OPT_MINMASK,
     /* equiv idx, value */ 19, VALUE_OPT_MINMASK,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ MINMASK_FLAGS, 0,
     /* last opt argumnt */ { MINMASK_DFT_ARG },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ aMinmaskMustList, NULL,
     /* option proc      */ doOptMinmask,
     /* desc, NAME, name */ MINMASK_DESC, MINMASK_NAME, MINMASK_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 20, VALUE_OPT_MAXMASK,
     /* equiv idx, value */ 20, VALUE_OPT_MAXMASK,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ MAXMASK_FLAGS, 0,
     /* last opt argumnt */ { MAXMASK_DFT_ARG },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ aMaxmaskMustList, NULL,
     /* option proc      */ doOptMaxmask,
     /* desc, NAME, name */ MAXMASK_DESC, MAXMASK_NAME, MAXMASK_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 21, VALUE_OPT_VERBOSE,
     /* equiv idx, value */ 21, VALUE_OPT_VERBOSE,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ VERBOSE_FLAGS, 0,
     /* last opt argumnt */ { NULL }, /* --verbose */
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ NULL,
     /* desc, NAME, name */ VERBOSE_DESC, VERBOSE_NAME, VERBOSE_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 22, VALUE_OPT_DECODE,
     /* equiv idx, value */ 22, VALUE_OPT_DECODE,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ DECODE_FLAGS, 0,
     /* last opt argumnt */ { NULL }, /* --decode */
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ aDecodeMustList, NULL,
     /* option proc      */ NULL,
     /* desc, NAME, name */ DECODE_DESC, DECODE_NAME, DECODE_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 23, VALUE_OPT_VERSION,
     /* equiv idx, value */ 23, VALUE_OPT_VERSION,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ VERSION_FLAGS, 0,
     /* last opt argumnt */ { NULL }, /* --version */
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ doOptVersion,
     /* desc, NAME, name */ VERSION_DESC, VERSION_NAME, VERSION_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 24, VALUE_OPT_LESS_HELP,
     /* equiv idx, value */ 24, VALUE_OPT_LESS_HELP,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ LESS_HELP_FLAGS, 0,
     /* last opt argumnt */ { NULL }, /* --less-help */
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ doOptLess_Help,
     /* desc, NAME, name */ LESS_HELP_DESC, LESS_HELP_NAME, LESS_HELP_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ INDEX_OPT_HELP, VALUE_OPT_HELP,
     /* equiv idx value  */ NO_EQUIVALENT, VALUE_OPT_HELP,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ OPTST_IMM | OPTST_NO_INIT, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ doUsageOpt,
     /* desc, NAME, name */ HELP_DESC, NULL, HELP_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ INDEX_OPT_MORE_HELP, VALUE_OPT_MORE_HELP,
     /* equiv idx value  */ NO_EQUIVALENT, VALUE_OPT_MORE_HELP,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ MORE_HELP_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL,  NULL,
     /* option proc      */ optionPagedUsage,
     /* desc, NAME, name */ MORE_HELP_DESC, NULL, MORE_HELP_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ INDEX_OPT_SAVE_OPTS, VALUE_OPT_SAVE_OPTS,
     /* equiv idx value  */ NO_EQUIVALENT, VALUE_OPT_SAVE_OPTS,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ OPTST_SET_ARGTYPE(OPARG_TYPE_STRING)
                          | OPTST_ARG_OPTIONAL | OPTST_NO_INIT, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL,  NULL,
     /* option proc      */ NULL,
     /* desc, NAME, name */ SAVE_OPTS_DESC, NULL, SAVE_OPTS_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ INDEX_OPT_LOAD_OPTS, VALUE_OPT_LOAD_OPTS,
     /* equiv idx value  */ NO_EQUIVALENT, VALUE_OPT_LOAD_OPTS,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, NOLIMIT, 0,
     /* opt state flags  */ OPTST_SET_ARGTYPE(OPARG_TYPE_STRING)
			  | OPTST_DISABLE_IMM, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ optionLoadOpt,
     /* desc, NAME, name */ LOAD_OPTS_DESC, LOAD_OPTS_NAME, LOAD_OPTS_name,
     /* disablement strs */ NO_LOAD_OPTS_name, LOAD_OPTS_pfx }
};


/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *
 *  Define the tcpprep Option Environment
 */
#define zPROGNAME       (tcpprep_opt_strs+2328)
#define zUsageTitle     (tcpprep_opt_strs+2336)
#define zRcName         (tcpprep_opt_strs+2472)
static char const * const apzHomeList[2] = {
    tcpprep_opt_strs+2468,
    NULL };
#define zBugsAddr       (tcpprep_opt_strs+2483)
#define zExplain        (tcpprep_opt_strs+2521)
#define zDetail         (tcpprep_opt_strs+2696)
#define zFullVersion    (NULL)
/* extracted from optcode.tlib near line 350 */

#if defined(ENABLE_NLS)
# define OPTPROC_BASE OPTPROC_TRANSLATE
  static tOptionXlateProc translate_option_strings;
#else
# define OPTPROC_BASE OPTPROC_NONE
# define translate_option_strings NULL
#endif /* ENABLE_NLS */


#define tcpprep_full_usage (NULL)

#define tcpprep_short_usage (NULL)

#endif /* not defined __doxygen__ */

/*
 *  Create the static procedure(s) declared above.
 */
/**
 * The callout function that invokes the optionUsage function.
 *
 * @param pOptions the AutoOpts option description structure
 * @param pOptDesc the descriptor for the "help" (usage) option.
 * @noreturn
 */
static void
doUsageOpt(tOptions * pOptions, tOptDesc * pOptDesc)
{
    optionUsage(&tcpprepOptions, TCPPREP_EXIT_SUCCESS);
    /* NOTREACHED */
    (void)pOptDesc;
    (void)pOptions;
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
/**
 * Code to handle the dbug option, when DEBUG is #define-d.
 *
 * @param pOptions the tcpprep options data structure
 * @param pOptDesc the option descriptor for this option.
 */
#ifdef DEBUG
static void
doOptDbug(tOptions* pOptions, tOptDesc* pOptDesc)
{
    static struct {long rmin, rmax;} const rng[1] = {
        { 0, 5 } };
    int  ix;

    if (pOptions <= OPTPROC_EMIT_LIMIT)
        goto emit_ranges;
    optionNumericVal(pOptions, pOptDesc);

    for (ix = 0; ix < 1; ix++) {
        if (pOptDesc->optArg.argInt < rng[ix].rmin)
            continue;  /* ranges need not be ordered. */
        if (pOptDesc->optArg.argInt == rng[ix].rmin)
            return;
        if (rng[ix].rmax == LONG_MIN)
            continue;
        if (pOptDesc->optArg.argInt <= rng[ix].rmax)
            return;
    }

    option_usage_fp = stderr;

emit_ranges:
    optionShowRange(pOptions, pOptDesc, (void *)rng, 1);
}
#endif /* defined DEBUG */

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
/**
 * Code to handle the auto option.
 *
 * @param pOptions the tcpprep options data structure
 * @param pOptDesc the option descriptor for this option.
 */
static void
doOptAuto(tOptions* pOptions, tOptDesc* pOptDesc)
{
    /* extracted from tcpprep_opts.def, line 113 */

    tcpprep->options->mode = AUTO_MODE;
    if (strcmp(OPT_ARG(AUTO), "bridge") == 0) {
        tcpprep->options->automode = BRIDGE_MODE;
    }
    else if (strcmp(OPT_ARG(AUTO), "router") == 0) {
        tcpprep->options->automode = ROUTER_MODE;
    }
    else if (strcmp(OPT_ARG(AUTO), "client") == 0) {
        tcpprep->options->automode = CLIENT_MODE;
    }
    else if (strcmp(OPT_ARG(AUTO), "server") == 0) {
        tcpprep->options->automode = SERVER_MODE;
    }
    else if (strcmp(OPT_ARG(AUTO), "first") == 0) {
        tcpprep->options->automode = FIRST_MODE;
    }
    else {
        errx(-1, "Invalid auto mode type: %s", OPT_ARG(AUTO));
    }
    (void)pOptDesc;
    (void)pOptions;
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
/**
 * Code to handle the cidr option.
 *
 * @param pOptions the tcpprep options data structure
 * @param pOptDesc the option descriptor for this option.
 */
static void
doOptCidr(tOptions* pOptions, tOptDesc* pOptDesc)
{
    /* extracted from tcpprep_opts.def, line 185 */

    char *cidr = safe_strdup(OPT_ARG(CIDR));
    tcpprep->options->mode = CIDR_MODE;
    if (!parse_cidr(&tcpprep->options->cidrdata, cidr, ","))
        errx(-1, "Unable to parse CIDR map: %s", OPT_ARG(CIDR));
    free(cidr);

    (void)pOptDesc;
    (void)pOptions;
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
/**
 * Code to handle the regex option.
 *
 * @param pOptions the tcpprep options data structure
 * @param pOptDesc the option descriptor for this option.
 */
static void
doOptRegex(tOptions* pOptions, tOptDesc* pOptDesc)
{
    /* extracted from tcpprep_opts.def, line 220 */

    int regex_error;
    char ebuf[EBUF_SIZE];

    tcpprep->options->mode = REGEX_MODE;
    if ((regex_error = regcomp(&tcpprep->options->preg, OPT_ARG(REGEX), 
        REG_EXTENDED|REG_NOSUB))) {
        regerror(regex_error, &tcpprep->options->preg, ebuf, EBUF_SIZE);
        errx(-1, "Unable to compile regex: %s", ebuf);
    }

    (void)pOptDesc;
    (void)pOptions;
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
/**
 * Code to handle the port option.
 *
 * @param pOptions the tcpprep options data structure
 * @param pOptDesc the option descriptor for this option.
 */
static void
doOptPort(tOptions* pOptions, tOptDesc* pOptDesc)
{
    /* extracted from tcpprep_opts.def, line 248 */

    tcpprep->options->mode = PORT_MODE;

    (void)pOptDesc;
    (void)pOptions;
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
/**
 * Code to handle the mac option.
 *
 * @param pOptions the tcpprep options data structure
 * @param pOptDesc the option descriptor for this option.
 */
static void
doOptMac(tOptions* pOptions, tOptDesc* pOptDesc)
{
    /* extracted from tcpprep_opts.def, line 269 */

    tcpprep->options->mode = MAC_MODE;
    tcpprep->options->maclist = safe_strdup(OPT_ARG(MAC));
    (void)pOptDesc;
    (void)pOptions;
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
/**
 * Code to handle the comment option.
 *
 * @param pOptions the tcpprep options data structure
 * @param pOptDesc the option descriptor for this option.
 */
static void
doOptComment(tOptions* pOptions, tOptDesc* pOptDesc)
{
    /* extracted from tcpprep_opts.def, line 300 */

    /* our comment_len is only 16bit - myargs[] */
    if (strlen(OPT_ARG(COMMENT)) > ((1 << 16) - 1 - MYARGS_LEN))
                errx(-1, "Comment length %zu is longer then max allowed (%d)", 
                strlen(OPT_ARG(COMMENT)), (1 << 16) - 1 - MYARGS_LEN);

    /* save the comment */
    tcpprep->options->comment = (char *)safe_malloc(strlen(OPT_ARG(COMMENT)) + 1);
    strcpy(tcpprep->options->comment, OPT_ARG(COMMENT));

    (void)pOptDesc;
    (void)pOptions;
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
/**
 * Code to handle the no-arg-comment option.
 *
 * @param pOptions the tcpprep options data structure
 * @param pOptDesc the option descriptor for this option.
 */
static void
doOptNo_Arg_Comment(tOptions* pOptions, tOptDesc* pOptDesc)
{
    /* extracted from tcpprep_opts.def, line 322 */

tcpprep->options->nocomment = 1;
    (void)pOptDesc;
    (void)pOptions;
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
/**
 * Code to handle the include option.
 *
 * @param pOptions the tcpprep options data structure
 * @param pOptDesc the option descriptor for this option.
 */
static void
doOptInclude(tOptions* pOptions, tOptDesc* pOptDesc)
{
    /* extracted from tcpprep_opts.def, line 342 */

    char *include;

    include = safe_strdup(OPT_ARG(INCLUDE));
    tcpprep->options->xX.mode = xX_MODE_INCLUDE;

    if ((tcpprep->options->xX.mode = parse_xX_str(&tcpprep->options->xX, include, &tcpprep->options->bpf)) == xXError)
        errx(-1, "Unable to parse include/exclude rule: %s", OPT_ARG(INCLUDE));

    free(include);

    (void)pOptDesc;
    (void)pOptions;
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
/**
 * Code to handle the exclude option.
 *
 * @param pOptions the tcpprep options data structure
 * @param pOptDesc the option descriptor for this option.
 */
static void
doOptExclude(tOptions* pOptions, tOptDesc* pOptDesc)
{
    /* extracted from tcpprep_opts.def, line 389 */

    char *exclude;

    exclude = safe_strdup(OPT_ARG(EXCLUDE));
    tcpprep->options->xX.mode = xX_MODE_EXCLUDE;

    if ((tcpprep->options->xX.mode = parse_xX_str(&tcpprep->options->xX, exclude, &tcpprep->options->bpf)) == xXError)
        errx(-1, "Unable to parse include/exclude rule: %s", OPT_ARG(EXCLUDE));

    free(exclude);

    (void)pOptDesc;
    (void)pOptions;
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
/**
 * Code to handle the services option.
 *
 * @param pOptions the tcpprep options data structure
 * @param pOptDesc the option descriptor for this option.
 */
static void
doOptServices(tOptions* pOptions, tOptDesc* pOptDesc)
{
    /* extracted from tcpprep_opts.def, line 486 */
    parse_services(OPT_ARG(SERVICES), &tcpprep->options->services);

    (void)pOptDesc;
    (void)pOptions;
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
/**
 * Code to handle the nonip option.
 *
 * @param pOptions the tcpprep options data structure
 * @param pOptDesc the option descriptor for this option.
 */
static void
doOptNonip(tOptions* pOptions, tOptDesc* pOptDesc)
{
    /* extracted from tcpprep_opts.def, line 497 */

    tcpprep->options->nonip = DIR_SERVER;

    (void)pOptDesc;
    (void)pOptions;
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
/**
 * Code to handle the minmask option.
 *
 * @param pOptions the tcpprep options data structure
 * @param pOptDesc the option descriptor for this option.
 */
static void
doOptMinmask(tOptions* pOptions, tOptDesc* pOptDesc)
{
    static struct {long rmin, rmax;} const rng[1] = {
        { 0, 32 } };
    int  ix;

    if (pOptions <= OPTPROC_EMIT_LIMIT)
        goto emit_ranges;
    optionNumericVal(pOptions, pOptDesc);

    for (ix = 0; ix < 1; ix++) {
        if (pOptDesc->optArg.argInt < rng[ix].rmin)
            continue;  /* ranges need not be ordered. */
        if (pOptDesc->optArg.argInt == rng[ix].rmin)
            return;
        if (rng[ix].rmax == LONG_MIN)
            continue;
        if (pOptDesc->optArg.argInt <= rng[ix].rmax)
            return;
    }

    option_usage_fp = stderr;

emit_ranges:
    optionShowRange(pOptions, pOptDesc, (void *)rng, 1);
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
/**
 * Code to handle the maxmask option.
 *
 * @param pOptions the tcpprep options data structure
 * @param pOptDesc the option descriptor for this option.
 */
static void
doOptMaxmask(tOptions* pOptions, tOptDesc* pOptDesc)
{
    static struct {long rmin, rmax;} const rng[1] = {
        { 0, 32 } };
    int  ix;

    if (pOptions <= OPTPROC_EMIT_LIMIT)
        goto emit_ranges;
    optionNumericVal(pOptions, pOptDesc);

    for (ix = 0; ix < 1; ix++) {
        if (pOptDesc->optArg.argInt < rng[ix].rmin)
            continue;  /* ranges need not be ordered. */
        if (pOptDesc->optArg.argInt == rng[ix].rmin)
            return;
        if (rng[ix].rmax == LONG_MIN)
            continue;
        if (pOptDesc->optArg.argInt <= rng[ix].rmax)
            return;
    }

    option_usage_fp = stderr;

emit_ranges:
    optionShowRange(pOptions, pOptDesc, (void *)rng, 1);
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
/**
 * Code to handle the version option.
 *
 * @param pOptions the tcpprep options data structure
 * @param pOptDesc the option descriptor for this option.
 */
static void
doOptVersion(tOptions* pOptions, tOptDesc* pOptDesc)
{
    /* extracted from tcpprep_opts.def, line 598 */

    fprintf(stderr, "tcpprep version: %s (build %s)", VERSION, git_version());
#ifdef DEBUG
    fprintf(stderr, " (debug)");
#endif
    fprintf(stderr, "\n");
    fprintf(stderr, "Copyright 2013-2014 by Fred Klassen <tcpreplay at appneta dot com> - AppNeta Inc.\n");
    fprintf(stderr, "Copyright 2000-2012 by Aaron Turner <aturner at synfin dot net>\n");
    fprintf(stderr, "The entire Tcpreplay Suite is licensed under the GPLv3\n");
    fprintf(stderr, "Cache file supported: %s\n", CACHEVERSION);
#ifdef HAVE_LIBDNET
    fprintf(stderr, "Compiled against libdnet: %s\n", LIBDNET_VERSION);
#else
    fprintf(stderr, "Not compiled with libdnet.\n");
#endif
#ifdef HAVE_WINPCAP
    fprintf(stderr, "Compiled against winpcap: %s\n", get_pcap_version());
#elif defined HAVE_PF_RING_PCAP
    fprintf(stderr, "Compiled against PF_RING libpcap: %s\n", get_pcap_version());
#else
    fprintf(stderr, "Compiled against libpcap: %s\n", get_pcap_version());
#endif
#ifdef ENABLE_64BITS
    fprintf(stderr, "64 bit packet counters: enabled\n");
#else
    fprintf(stderr, "64 bit packet counters: disabled\n");
#endif
#ifdef ENABLE_VERBOSE
    fprintf(stderr, "Verbose printing via tcpdump: enabled\n");
#else
    fprintf(stderr, "Verbose printing via tcpdump: disabled\n");
#endif
    exit(0);

    (void)pOptDesc;
    (void)pOptions;
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
/**
 * Code to handle the less-help option.
 *
 * @param pOptions the tcpprep options data structure
 * @param pOptDesc the option descriptor for this option.
 */
static void
doOptLess_Help(tOptions* pOptions, tOptDesc* pOptDesc)
{
    /* extracted from tcpprep_opts.def, line 642 */

    USAGE(EXIT_FAILURE);

    (void)pOptDesc;
    (void)pOptions;
}
/* extracted from optmain.tlib near line 1146 */

/**
 * The directory containing the data associated with tcpprep.
 */
#ifndef  PKGDATADIR
# define PKGDATADIR ""
#endif

/**
 * Information about the person or institution that packaged tcpprep
 * for the current distribution.
 */
#ifndef  WITH_PACKAGER
# define tcpprep_packager_info NULL
#else
static char const tcpprep_packager_info[] =
    "Packaged by " WITH_PACKAGER

# ifdef WITH_PACKAGER_VERSION
        " ("WITH_PACKAGER_VERSION")"
# endif

# ifdef WITH_PACKAGER_BUG_REPORTS
    "\nReport tcpprep bugs to " WITH_PACKAGER_BUG_REPORTS
# endif
    "\n";
#endif
#ifndef __doxygen__

#endif /* __doxygen__ */
/**
 * The option definitions for tcpprep.  The one structure that
 * binds them all.
 */
tOptions tcpprepOptions = {
    OPTIONS_STRUCT_VERSION,
    0, NULL,                    /* original argc + argv    */
    ( OPTPROC_BASE
    + OPTPROC_ERRSTOP
    + OPTPROC_SHORTOPT
    + OPTPROC_LONGOPT
    + OPTPROC_NO_REQ_OPT
    + OPTPROC_NO_ARGS
    + OPTPROC_GNUUSAGE ),
    0, NULL,                    /* current option index, current option */
    NULL,         NULL,         zPROGNAME,
    zRcName,      zCopyright,   zLicenseDescrip,
    zFullVersion, apzHomeList,  zUsageTitle,
    zExplain,     zDetail,      optDesc,
    zBugsAddr,                  /* address to send bugs to */
    NULL, NULL,                 /* extensions/saved state  */
    optionUsage, /* usage procedure */
    translate_option_strings,   /* translation procedure */
    /*
     *  Indexes to special options
     */
    { INDEX_OPT_MORE_HELP, /* more-help option index */
      INDEX_OPT_SAVE_OPTS, /* save option index */
      NO_EQUIVALENT, /* '-#' option index */
      NO_EQUIVALENT /* index of default opt */
    },
    29 /* full option count */, 25 /* user option count */,
    tcpprep_full_usage, tcpprep_short_usage,
    NULL, NULL,
    PKGDATADIR, tcpprep_packager_info
};

#if ENABLE_NLS
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <autoopts/usage-txt.h>

static char* AO_gettext(char const* pz);
static void  coerce_it(void** s);

/**
 * AutoGen specific wrapper function for gettext.
 * It relies on the macro _() to convert from English to the target
 * language, then strdup-duplicates the result string.
 *
 * @param[in] pz the input text used as a lookup key.
 * @returns the translated text (if there is one),
 *   or the original text (if not).
 */
static char *
AO_gettext(char const* pz)
{
    char* pzRes;
    if (pz == NULL)
        return NULL;
    pzRes = _(pz);
    if (pzRes == pz)
        return pzRes;
    pzRes = strdup(pzRes);
    if (pzRes == NULL) {
        fputs(_("No memory for duping translated strings\n"), stderr);
        exit(TCPPREP_EXIT_FAILURE);
    }
    return pzRes;
}

static void coerce_it(void** s) { *s = AO_gettext(*s);
}

/**
 * Translate all the translatable strings in the tcpprepOptions
 * structure defined above.  This is done only once.
 */
static void
translate_option_strings(void)
{
    tOptions * const pOpt = &tcpprepOptions;

    /*
     *  Guard against re-translation.  It won't work.  The strings will have
     *  been changed by the first pass through this code.  One shot only.
     */
    if (option_usage_text.field_ct != 0) {
        /*
         *  Do the translations.  The first pointer follows the field count
         *  field.  The field count field is the size of a pointer.
         */
        tOptDesc * pOD = pOpt->pOptDesc;
        char **    ppz = (char**)(void*)&(option_usage_text);
        int        ix  = option_usage_text.field_ct;

        do {
            ppz++;
            *ppz = AO_gettext(*ppz);
        } while (--ix > 0);

        coerce_it((void*)&(pOpt->pzCopyright));
        coerce_it((void*)&(pOpt->pzCopyNotice));
        coerce_it((void*)&(pOpt->pzFullVersion));
        coerce_it((void*)&(pOpt->pzUsageTitle));
        coerce_it((void*)&(pOpt->pzExplain));
        coerce_it((void*)&(pOpt->pzDetail));
        coerce_it((void*)&(pOpt->pzPackager));
        option_usage_text.field_ct = 0;

        for (ix = pOpt->optCt; ix > 0; ix--, pOD++)
            coerce_it((void*)&(pOD->pzText));
    }

    if ((pOpt->fOptSet & OPTPROC_NXLAT_OPT_CFG) == 0) {
        tOptDesc * pOD = pOpt->pOptDesc;
        int        ix;

        for (ix = pOpt->optCt; ix > 0; ix--, pOD++) {
            coerce_it((void*)&(pOD->pz_Name));
            coerce_it((void*)&(pOD->pz_DisableName));
            coerce_it((void*)&(pOD->pz_DisablePfx));
        }
        /* prevent re-translation */
        tcpprepOptions.fOptSet |= OPTPROC_NXLAT_OPT_CFG | OPTPROC_NXLAT_OPT;
    }
}

#endif /* ENABLE_NLS */

#ifdef  __cplusplus
}
#endif
/* tcpprep_opts.c ends here */
