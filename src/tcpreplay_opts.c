/*   -*- buffer-read-only: t -*- vi: set ro:
 *  
 *  DO NOT EDIT THIS FILE   (tcpreplay_opts.c)
 *  
 *  It has been AutoGen-ed  December 17, 2014 at 03:12:31 PM by AutoGen 5.16.2
 *  From the definitions    tcpreplay_opts.def
 *  and the template file   options
 *
 * Generated from AutoOpts 36:5:11 templates.
 *
 *  AutoOpts is a copyrighted work.  This source file is not encumbered
 *  by AutoOpts licensing, but is provided under the licensing terms chosen
 *  by the tcpreplay author or copyright holder.  AutoOpts is
 *  licensed under the terms of the LGPL.  The redistributable library
 *  (``libopts'') is licensed under the terms of either the LGPL or, at the
 *  users discretion, the BSD license.  See the AutoOpts and/or libopts sources
 *  for details.
 *
 * The tcpreplay program is copyrighted and licensed
 * under the following terms:
 *
 *  Copyright (C) 2000-2014 Aaron Turner and Fred Klassen, all rights reserved.
 *  This is free software. It is licensed for use, modification and
 *  redistribution under the terms of the
 *  GNU General Public License, version 3 or later
 *      <http://gnu.org/licenses/gpl.html>
 *
 *  tcpreplay is free software: you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by the
 *  Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *  
 *  tcpreplay is distributed in the hope that it will be useful, but
 *  WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 *  See the GNU General Public License for more details.
 *  
 *  You should have received a copy of the GNU General Public License along
 *  with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#ifndef __doxygen__
#define OPTION_CODE_COMPILE 1
#include "tcpreplay_opts.h"
#include <sys/types.h>

#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>

#ifdef  __cplusplus
extern "C" {
#endif
extern FILE * option_usage_fp;

/* TRANSLATORS: choose the translation for option names wisely because you
                cannot ever change your mind. */
#define zCopyright      (tcpreplay_opt_strs+0)
#define zLicenseDescrip (tcpreplay_opt_strs+287)

/*
 *  global included definitions
 */
#include "defines.h"
#include "tcpreplay.h"
#include "common.h"
#include "config.h"
#include <stdlib.h>
#include <sys/types.h>
#include <unistd.h>


#ifndef NULL
#  define NULL 0
#endif

/*
 *  tcpreplay option static const strings
 */
static char const tcpreplay_opt_strs[3802] =
/*     0 */ "tcpreplay (tcpreplay)\n"
            "Copyright (C) 2000-2014 Aaron Turner and Fred Klassen, all rights reserved.\n"
            "This is free software. It is licensed for use, modification and\n"
            "redistribution under the terms of the\n"
            "GNU General Public License, version 3 or later\n"
            "    <http://gnu.org/licenses/gpl.html>\n\0"
/*   287 */ "tcpreplay is free software: you can redistribute it and/or modify it under\n"
            "the terms of the GNU General Public License as published by the Free\n"
            "Software Foundation, either version 3 of the License, or (at your option)\n"
            "any later version.\n\n"
            "tcpreplay is distributed in the hope that it will be useful, but WITHOUT\n"
            "ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n"
            "FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n"
            "more details.\n\n"
            "You should have received a copy of the GNU General Public License along\n"
            "with this program.  If not, see <http://www.gnu.org/licenses/>.\n\0"
/*   894 */ "Enable debugging output\0"
/*   918 */ "DBUG\0"
/*   923 */ "dbug\0"
/*   928 */ "Quiet mode\0"
/*   939 */ "QUIET\0"
/*   945 */ "quiet\0"
/*   951 */ "Select packet timing mode: select, ioport, gtod, nano\0"
/*  1005 */ "TIMER\0"
/*  1011 */ "timer\0"
/*  1017 */ "gtod\0"
/*  1022 */ "Sleep for no more then X milliseconds between packets\0"
/*  1076 */ "MAXSLEEP\0"
/*  1085 */ "maxsleep\0"
/*  1094 */ "Print decoded packets via tcpdump to STDOUT\0"
/*  1138 */ "VERBOSE\0"
/*  1146 */ "verbose\0"
/*  1154 */ "Arguments passed to tcpdump decoder\0"
/*  1190 */ "DECODE\0"
/*  1197 */ "decode\0"
/*  1204 */ "Preloads packets into RAM before sending\0"
/*  1245 */ "PRELOAD_PCAP\0"
/*  1258 */ "preload-pcap\0"
/*  1271 */ "Split traffic via a tcpprep cache file\0"
/*  1310 */ "CACHEFILE\0"
/*  1320 */ "cachefile\0"
/*  1330 */ "Replay two files at a time from a network tap\0"
/*  1376 */ "DUALFILE\0"
/*  1385 */ "dualfile\0"
/*  1394 */ "Client to server/RX/primary traffic output interface\0"
/*  1447 */ "INTF1\0"
/*  1453 */ "intf1\0"
/*  1459 */ "Server to client/TX/secondary traffic output interface\0"
/*  1514 */ "INTF2\0"
/*  1520 */ "intf2\0"
/*  1526 */ "List available network interfaces and exit\0"
/*  1569 */ "LISTNICS\0"
/*  1578 */ "listnics\0"
/*  1587 */ "Loop through the capture file X times\0"
/*  1625 */ "LOOP\0"
/*  1630 */ "loop\0"
/*  1635 */ "Delay between loops in milliseconds\0"
/*  1671 */ "LOOPDELAY_MS\0"
/*  1684 */ "loopdelay-ms\0"
/*  1697 */ "Override the snaplen and use the actual packet len\0"
/*  1748 */ "PKTLEN\0"
/*  1755 */ "pktlen\0"
/*  1762 */ "Limit the number of packets to send\0"
/*  1798 */ "LIMIT\0"
/*  1804 */ "limit\0"
/*  1810 */ "Modify replay speed to a given multiple\0"
/*  1850 */ "MULTIPLIER\0"
/*  1861 */ "multiplier\0"
/*  1872 */ "Replay packets at a given packets/sec\0"
/*  1910 */ "PPS\0"
/*  1914 */ "pps\0"
/*  1918 */ "Replay packets at a given Mbps\0"
/*  1949 */ "MBPS\0"
/*  1954 */ "mbps\0"
/*  1959 */ "Replay packets as fast as possible\0"
/*  1994 */ "TOPSPEED\0"
/*  2003 */ "topspeed\0"
/*  2012 */ "Replay one packet at a time for each user input\0"
/*  2060 */ "ONEATATIME\0"
/*  2071 */ "oneatatime\0"
/*  2082 */ "Number of packets to send for each time interval\0"
/*  2131 */ "PPS_MULTI\0"
/*  2141 */ "pps-multi\0"
/*  2151 */ "Modify IP addresses each loop iteration to generate unique flows\0"
/*  2216 */ "UNIQUE_IP\0"
/*  2226 */ "unique-ip\0"
/*  2236 */ "Write packets directly to netmap enabled network adapter\0"
/*  2293 */ "NETMAP\0"
/*  2300 */ "netmap\0"
/*  2307 */ "Netmap startup delay\0"
/*  2328 */ "NM_DELAY\0"
/*  2337 */ "nm-delay\0"
/*  2346 */ "Suppress printing and tracking flow count, rates and expirations\0"
/*  2411 */ "NO_FLOW_STATS\0"
/*  2425 */ "no-flow-stats\0"
/*  2439 */ "Number of inactive seconds before a flow is considered expired\0"
/*  2502 */ "FLOW_EXPIRY\0"
/*  2514 */ "flow-expiry\0"
/*  2526 */ "Print the PID of tcpreplay at startup\0"
/*  2564 */ "PID\0"
/*  2568 */ "pid\0"
/*  2572 */ "Write packets directly to an interface via Quick_TX module\0"
/*  2631 */ "QUICK_TX\0"
/*  2640 */ "quick-tx\0"
/*  2649 */ "Print statistics every X seconds\0"
/*  2682 */ "STATS\0"
/*  2688 */ "stats\0"
/*  2694 */ "Print version information\0"
/*  2720 */ "VERSION\0"
/*  2728 */ "version\0"
/*  2736 */ "Display less usage information and exit\0"
/*  2776 */ "LESS_HELP\0"
/*  2786 */ "less-help\0"
/*  2796 */ "Display extended usage information and exit\0"
/*  2840 */ "help\0"
/*  2845 */ "Extended usage information passed thru pager\0"
/*  2890 */ "more-help\0"
/*  2900 */ "Save the option state to a config file\0"
/*  2939 */ "save-opts\0"
/*  2949 */ "Load options from a config file\0"
/*  2981 */ "LOAD_OPTS\0"
/*  2991 */ "no-load-opts\0"
/*  3004 */ "no\0"
/*  3007 */ "TCPREPLAY\0"
/*  3017 */ "tcpreplay (tcpreplay) - Replay network traffic stored in pcap files\n"
            "USAGE:  %s [ -<flag> [<val>] | --<name>[{=| }<val>] ]... <pcap_file(s)>\n\0"
/*  3158 */ "$$/\0"
/*  3162 */ ".tcpreplayrc\0"
/*  3175 */ "tcpreplay-users@lists.sourceforge.net\0"
/*  3213 */ "\n"
            "tcpreplay is a tool for replaying network traffic from files saved with\n"
            "tcpdump or other tools which write pcap(3) files.\n\0"
/*  3337 */ "\n"
            "The basic operation of tcpreplay is to resend all packets from the input\n"
            "file(s) at the speed at which they were recorded, or a specified data rate,\n"
            "up to as fast as the hardware is capable.\n\n"
            "Optionally, the traffic can be split between two interfaces, written to\n"
            "files, filtered and edited in various ways, providing the means to test\n"
            "firewalls, NIDS and other network devices.\n\n"
            "For more details, please see the Tcpreplay Manual at:\n"
            "http://tcpreplay.appneta.com\n";

/*
 *  dbug option description:
 */
#ifdef DEBUG
#define DBUG_DESC      (tcpreplay_opt_strs+894)
#define DBUG_NAME      (tcpreplay_opt_strs+918)
#define DBUG_name      (tcpreplay_opt_strs+923)
#define DBUG_DFT_ARG   ((char const*)0)
#define DBUG_FLAGS     (OPTST_DISABLED | OPTST_IMM \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_NUMERIC))

#else   /* disable dbug */
#define DBUG_FLAGS     (OPTST_OMITTED | OPTST_NO_INIT)
#define DBUG_DFT_ARG   NULL
#define DBUG_NAME      NULL
#define DBUG_DESC      NULL
#define DBUG_name      NULL
#endif  /* DEBUG */

/*
 *  quiet option description:
 */
#define QUIET_DESC      (tcpreplay_opt_strs+928)
#define QUIET_NAME      (tcpreplay_opt_strs+939)
#define QUIET_name      (tcpreplay_opt_strs+945)
#define QUIET_FLAGS     (OPTST_DISABLED)

/*
 *  timer option description:
 */
#define TIMER_DESC      (tcpreplay_opt_strs+951)
#define TIMER_NAME      (tcpreplay_opt_strs+1005)
#define TIMER_name      (tcpreplay_opt_strs+1011)
#define TIMER_DFT_ARG   (tcpreplay_opt_strs+1017)
#define TIMER_FLAGS     (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_STRING))

/*
 *  maxsleep option description:
 */
#define MAXSLEEP_DESC      (tcpreplay_opt_strs+1022)
#define MAXSLEEP_NAME      (tcpreplay_opt_strs+1076)
#define MAXSLEEP_name      (tcpreplay_opt_strs+1085)
#define MAXSLEEP_DFT_ARG   ((char const*)0)
#define MAXSLEEP_FLAGS     (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_NUMERIC))

/*
 *  verbose option description:
 */
#ifdef ENABLE_VERBOSE
#define VERBOSE_DESC      (tcpreplay_opt_strs+1094)
#define VERBOSE_NAME      (tcpreplay_opt_strs+1138)
#define VERBOSE_name      (tcpreplay_opt_strs+1146)
#define VERBOSE_FLAGS     (OPTST_DISABLED | OPTST_IMM)

#else   /* disable verbose */
#define VERBOSE_FLAGS     (OPTST_OMITTED | OPTST_NO_INIT)
#define VERBOSE_NAME      NULL
#define VERBOSE_DESC      NULL
#define VERBOSE_name      NULL
#endif  /* ENABLE_VERBOSE */

/*
 *  decode option description with
 *  "Must also have options" and "Incompatible options":
 */
#ifdef ENABLE_VERBOSE
#define DECODE_DESC      (tcpreplay_opt_strs+1154)
#define DECODE_NAME      (tcpreplay_opt_strs+1190)
#define DECODE_name      (tcpreplay_opt_strs+1197)
static int const aDecodeMustList[] = {
    INDEX_OPT_VERBOSE, NO_EQUIVALENT };
#define DECODE_FLAGS     (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_STRING))

#else   /* disable decode */
#define DECODE_FLAGS     (OPTST_OMITTED | OPTST_NO_INIT)
#define aDecodeMustList   NULL
#define DECODE_NAME      NULL
#define DECODE_DESC      NULL
#define DECODE_name      NULL
#endif  /* ENABLE_VERBOSE */

/*
 *  preload_pcap option description:
 */
#define PRELOAD_PCAP_DESC      (tcpreplay_opt_strs+1204)
#define PRELOAD_PCAP_NAME      (tcpreplay_opt_strs+1245)
#define PRELOAD_PCAP_name      (tcpreplay_opt_strs+1258)
#define PRELOAD_PCAP_FLAGS     (OPTST_DISABLED)

/*
 *  cachefile option description with
 *  "Must also have options" and "Incompatible options":
 */
#define CACHEFILE_DESC      (tcpreplay_opt_strs+1271)
#define CACHEFILE_NAME      (tcpreplay_opt_strs+1310)
#define CACHEFILE_name      (tcpreplay_opt_strs+1320)
static int const aCachefileMustList[] = {
    INDEX_OPT_INTF2, NO_EQUIVALENT };
static int const aCachefileCantList[] = {
    INDEX_OPT_DUALFILE, NO_EQUIVALENT };
#define CACHEFILE_FLAGS     (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_STRING))

/*
 *  dualfile option description with
 *  "Must also have options" and "Incompatible options":
 */
#define DUALFILE_DESC      (tcpreplay_opt_strs+1330)
#define DUALFILE_NAME      (tcpreplay_opt_strs+1376)
#define DUALFILE_name      (tcpreplay_opt_strs+1385)
static int const aDualfileMustList[] = {
    INDEX_OPT_INTF2, NO_EQUIVALENT };
static int const aDualfileCantList[] = {
    INDEX_OPT_CACHEFILE, NO_EQUIVALENT };
#define DUALFILE_FLAGS     (OPTST_DISABLED)

/*
 *  intf1 option description:
 */
#define INTF1_DESC      (tcpreplay_opt_strs+1394)
#define INTF1_NAME      (tcpreplay_opt_strs+1447)
#define INTF1_name      (tcpreplay_opt_strs+1453)
#define INTF1_FLAGS     (OPTST_DISABLED | OPTST_MUST_SET \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_STRING))

/*
 *  intf2 option description:
 */
#define INTF2_DESC      (tcpreplay_opt_strs+1459)
#define INTF2_NAME      (tcpreplay_opt_strs+1514)
#define INTF2_name      (tcpreplay_opt_strs+1520)
#define INTF2_FLAGS     (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_STRING))

/*
 *  listnics option description:
 */
#ifdef ENABLE_PCAP_FINDALLDEVS
#define LISTNICS_DESC      (tcpreplay_opt_strs+1526)
#define LISTNICS_NAME      (tcpreplay_opt_strs+1569)
#define LISTNICS_name      (tcpreplay_opt_strs+1578)
#define LISTNICS_FLAGS     (OPTST_DISABLED | OPTST_IMM)

#else   /* disable listnics */
#define LISTNICS_FLAGS     (OPTST_OMITTED | OPTST_NO_INIT)
#define LISTNICS_NAME      NULL
#define LISTNICS_DESC      NULL
#define LISTNICS_name      NULL
#endif  /* ENABLE_PCAP_FINDALLDEVS */

/*
 *  loop option description:
 */
#define LOOP_DESC      (tcpreplay_opt_strs+1587)
#define LOOP_NAME      (tcpreplay_opt_strs+1625)
#define LOOP_name      (tcpreplay_opt_strs+1630)
#define LOOP_DFT_ARG   ((char const*)1)
#define LOOP_FLAGS     (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_NUMERIC))

/*
 *  loopdelay-ms option description with
 *  "Must also have options" and "Incompatible options":
 */
#define LOOPDELAY_MS_DESC      (tcpreplay_opt_strs+1635)
#define LOOPDELAY_MS_NAME      (tcpreplay_opt_strs+1671)
#define LOOPDELAY_MS_name      (tcpreplay_opt_strs+1684)
#define LOOPDELAY_MS_DFT_ARG   ((char const*)0)
static int const aLoopdelay_MsMustList[] = {
    INDEX_OPT_LOOP, NO_EQUIVALENT };
#define LOOPDELAY_MS_FLAGS     (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_NUMERIC))

/*
 *  pktlen option description:
 */
#define PKTLEN_DESC      (tcpreplay_opt_strs+1697)
#define PKTLEN_NAME      (tcpreplay_opt_strs+1748)
#define PKTLEN_name      (tcpreplay_opt_strs+1755)
#define PKTLEN_FLAGS     (OPTST_DISABLED)

/*
 *  limit option description:
 */
#define LIMIT_DESC      (tcpreplay_opt_strs+1762)
#define LIMIT_NAME      (tcpreplay_opt_strs+1798)
#define LIMIT_name      (tcpreplay_opt_strs+1804)
#define LIMIT_DFT_ARG   ((char const*)-1)
#define LIMIT_FLAGS     (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_NUMERIC))

/*
 *  multiplier option description with
 *  "Must also have options" and "Incompatible options":
 */
#define MULTIPLIER_DESC      (tcpreplay_opt_strs+1810)
#define MULTIPLIER_NAME      (tcpreplay_opt_strs+1850)
#define MULTIPLIER_name      (tcpreplay_opt_strs+1861)
static int const aMultiplierCantList[] = {
    INDEX_OPT_PPS,
    INDEX_OPT_MBPS,
    INDEX_OPT_ONEATATIME,
    INDEX_OPT_TOPSPEED, NO_EQUIVALENT };
#define MULTIPLIER_FLAGS     (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_STRING))

/*
 *  pps option description with
 *  "Must also have options" and "Incompatible options":
 */
#define PPS_DESC      (tcpreplay_opt_strs+1872)
#define PPS_NAME      (tcpreplay_opt_strs+1910)
#define PPS_name      (tcpreplay_opt_strs+1914)
static int const aPpsCantList[] = {
    INDEX_OPT_MULTIPLIER,
    INDEX_OPT_MBPS,
    INDEX_OPT_ONEATATIME,
    INDEX_OPT_TOPSPEED, NO_EQUIVALENT };
#define PPS_FLAGS     (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_NUMERIC))

/*
 *  mbps option description with
 *  "Must also have options" and "Incompatible options":
 */
#define MBPS_DESC      (tcpreplay_opt_strs+1918)
#define MBPS_NAME      (tcpreplay_opt_strs+1949)
#define MBPS_name      (tcpreplay_opt_strs+1954)
static int const aMbpsCantList[] = {
    INDEX_OPT_MULTIPLIER,
    INDEX_OPT_PPS,
    INDEX_OPT_ONEATATIME,
    INDEX_OPT_TOPSPEED, NO_EQUIVALENT };
#define MBPS_FLAGS     (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_STRING))

/*
 *  topspeed option description with
 *  "Must also have options" and "Incompatible options":
 */
#define TOPSPEED_DESC      (tcpreplay_opt_strs+1959)
#define TOPSPEED_NAME      (tcpreplay_opt_strs+1994)
#define TOPSPEED_name      (tcpreplay_opt_strs+2003)
static int const aTopspeedCantList[] = {
    INDEX_OPT_MBPS,
    INDEX_OPT_MULTIPLIER,
    INDEX_OPT_PPS,
    INDEX_OPT_ONEATATIME, NO_EQUIVALENT };
#define TOPSPEED_FLAGS     (OPTST_DISABLED)

/*
 *  oneatatime option description with
 *  "Must also have options" and "Incompatible options":
 */
#define ONEATATIME_DESC      (tcpreplay_opt_strs+2012)
#define ONEATATIME_NAME      (tcpreplay_opt_strs+2060)
#define ONEATATIME_name      (tcpreplay_opt_strs+2071)
static int const aOneatatimeCantList[] = {
    INDEX_OPT_MBPS,
    INDEX_OPT_PPS,
    INDEX_OPT_MULTIPLIER,
    INDEX_OPT_TOPSPEED, NO_EQUIVALENT };
#define ONEATATIME_FLAGS     (OPTST_DISABLED)

/*
 *  pps-multi option description with
 *  "Must also have options" and "Incompatible options":
 */
#define PPS_MULTI_DESC      (tcpreplay_opt_strs+2082)
#define PPS_MULTI_NAME      (tcpreplay_opt_strs+2131)
#define PPS_MULTI_name      (tcpreplay_opt_strs+2141)
#define PPS_MULTI_DFT_ARG   ((char const*)1)
static int const aPps_MultiMustList[] = {
    INDEX_OPT_PPS, NO_EQUIVALENT };
#define PPS_MULTI_FLAGS     (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_NUMERIC))

/*
 *  unique-ip option description with
 *  "Must also have options" and "Incompatible options":
 */
#define UNIQUE_IP_DESC      (tcpreplay_opt_strs+2151)
#define UNIQUE_IP_NAME      (tcpreplay_opt_strs+2216)
#define UNIQUE_IP_name      (tcpreplay_opt_strs+2226)
static int const aUnique_IpMustList[] = {
    INDEX_OPT_LOOP, NO_EQUIVALENT };
#define UNIQUE_IP_FLAGS     (OPTST_DISABLED)

/*
 *  netmap option description:
 */
#ifdef HAVE_NETMAP
#define NETMAP_DESC      (tcpreplay_opt_strs+2236)
#define NETMAP_NAME      (tcpreplay_opt_strs+2293)
#define NETMAP_name      (tcpreplay_opt_strs+2300)
#define NETMAP_FLAGS     (OPTST_DISABLED)

#else   /* disable netmap */
#define NETMAP_FLAGS     (OPTST_OMITTED | OPTST_NO_INIT)
#define NETMAP_NAME      NULL
#define NETMAP_DESC      NULL
#define NETMAP_name      NULL
#endif  /* HAVE_NETMAP */

/*
 *  nm-delay option description with
 *  "Must also have options" and "Incompatible options":
 */
#ifdef HAVE_NETMAP
#define NM_DELAY_DESC      (tcpreplay_opt_strs+2307)
#define NM_DELAY_NAME      (tcpreplay_opt_strs+2328)
#define NM_DELAY_name      (tcpreplay_opt_strs+2337)
#define NM_DELAY_DFT_ARG   ((char const*)4)
static int const aNm_DelayMustList[] = {
    INDEX_OPT_NETMAP, NO_EQUIVALENT };
#define NM_DELAY_FLAGS     (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_NUMERIC))

#else   /* disable nm-delay */
#define NM_DELAY_FLAGS     (OPTST_OMITTED | OPTST_NO_INIT)
#define NM_DELAY_DFT_ARG   NULL
#define aNm_DelayMustList   NULL
#define NM_DELAY_NAME      NULL
#define NM_DELAY_DESC      NULL
#define NM_DELAY_name      NULL
#endif  /* HAVE_NETMAP */

/*
 *  no-flow-stats option description:
 */
#define NO_FLOW_STATS_DESC      (tcpreplay_opt_strs+2346)
#define NO_FLOW_STATS_NAME      (tcpreplay_opt_strs+2411)
#define NO_FLOW_STATS_name      (tcpreplay_opt_strs+2425)
#define NO_FLOW_STATS_FLAGS     (OPTST_DISABLED)

/*
 *  flow-expiry option description with
 *  "Must also have options" and "Incompatible options":
 */
#define FLOW_EXPIRY_DESC      (tcpreplay_opt_strs+2439)
#define FLOW_EXPIRY_NAME      (tcpreplay_opt_strs+2502)
#define FLOW_EXPIRY_name      (tcpreplay_opt_strs+2514)
#define FLOW_EXPIRY_DFT_ARG   ((char const*)0)
static int const aFlow_ExpiryCantList[] = {
    INDEX_OPT_NO_FLOW_STATS, NO_EQUIVALENT };
#define FLOW_EXPIRY_FLAGS     (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_NUMERIC))

/*
 *  pid option description:
 */
#define PID_DESC      (tcpreplay_opt_strs+2526)
#define PID_NAME      (tcpreplay_opt_strs+2564)
#define PID_name      (tcpreplay_opt_strs+2568)
#define PID_FLAGS     (OPTST_DISABLED)

/*
 *  quick-tx option description:
 */
#define QUICK_TX_DESC      (tcpreplay_opt_strs+2572)
#define QUICK_TX_NAME      (tcpreplay_opt_strs+2631)
#define QUICK_TX_name      (tcpreplay_opt_strs+2640)
#define QUICK_TX_FLAGS     (OPTST_DISABLED)

/*
 *  stats option description:
 */
#define STATS_DESC      (tcpreplay_opt_strs+2649)
#define STATS_NAME      (tcpreplay_opt_strs+2682)
#define STATS_name      (tcpreplay_opt_strs+2688)
#define STATS_FLAGS     (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_NUMERIC))

/*
 *  version option description:
 */
#define VERSION_DESC      (tcpreplay_opt_strs+2694)
#define VERSION_NAME      (tcpreplay_opt_strs+2720)
#define VERSION_name      (tcpreplay_opt_strs+2728)
#define VERSION_FLAGS     (OPTST_DISABLED)

/*
 *  less-help option description:
 */
#define LESS_HELP_DESC      (tcpreplay_opt_strs+2736)
#define LESS_HELP_NAME      (tcpreplay_opt_strs+2776)
#define LESS_HELP_name      (tcpreplay_opt_strs+2786)
#define LESS_HELP_FLAGS     (OPTST_DISABLED | OPTST_IMM)

/*
 *  Help/More_Help option descriptions:
 */
#define HELP_DESC       (tcpreplay_opt_strs+2796)
#define HELP_name       (tcpreplay_opt_strs+2840)
#ifdef HAVE_WORKING_FORK
#define MORE_HELP_DESC  (tcpreplay_opt_strs+2845)
#define MORE_HELP_name  (tcpreplay_opt_strs+2890)
#define MORE_HELP_FLAGS (OPTST_IMM | OPTST_NO_INIT)
#else
#define MORE_HELP_DESC  NULL
#define MORE_HELP_name  NULL
#define MORE_HELP_FLAGS (OPTST_OMITTED | OPTST_NO_INIT)
#endif
#define SAVE_OPTS_DESC  (tcpreplay_opt_strs+2900)
#define SAVE_OPTS_name  (tcpreplay_opt_strs+2939)
#define LOAD_OPTS_DESC     (tcpreplay_opt_strs+2949)
#define LOAD_OPTS_NAME     (tcpreplay_opt_strs+2981)
#define NO_LOAD_OPTS_name  (tcpreplay_opt_strs+2991)
#define LOAD_OPTS_pfx      (tcpreplay_opt_strs+3004)
#define LOAD_OPTS_name     (NO_LOAD_OPTS_name + 3)
/*
 *  Declare option callback procedures
 */
#ifdef DEBUG
  static tOptProc doOptDbug;
#else /* not DEBUG */
# define doOptDbug NULL
#endif /* def/not DEBUG */
#ifdef ENABLE_PCAP_FINDALLDEVS
  static tOptProc doOptListnics;
#else /* not ENABLE_PCAP_FINDALLDEVS */
# define doOptListnics NULL
#endif /* def/not ENABLE_PCAP_FINDALLDEVS */
extern tOptProc
    optionBooleanVal,   optionNestedVal,    optionNumericVal,
    optionPagedUsage,   optionPrintVersion, optionResetOpt,
    optionStackArg,     optionTimeDate,     optionTimeVal,
    optionUnstackArg,   optionVendorOption;
static tOptProc
    doOptFlow_Expiry,  doOptLess_Help,    doOptLimit,
    doOptLoop,         doOptLoopdelay_Ms, doOptPid,
    doOptPps_Multi,    doOptStats,        doOptVersion,
    doUsageOpt;

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
/**
 *  Define the tcpreplay Option Descriptions.
 * This is an array of OPTION_CT entries, one for each
 * option that the tcpreplay program responds to.
 */
static tOptDesc optDesc[OPTION_CT] = {
  {  /* entry idx, value */ 0, VALUE_OPT_DBUG,
     /* equiv idx, value */ 0, VALUE_OPT_DBUG,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ DBUG_FLAGS, 0,
     /* last opt argumnt */ { DBUG_DFT_ARG },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ doOptDbug,
     /* desc, NAME, name */ DBUG_DESC, DBUG_NAME, DBUG_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 1, VALUE_OPT_QUIET,
     /* equiv idx, value */ 1, VALUE_OPT_QUIET,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ QUIET_FLAGS, 0,
     /* last opt argumnt */ { NULL }, /* --quiet */
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ NULL,
     /* desc, NAME, name */ QUIET_DESC, QUIET_NAME, QUIET_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 2, VALUE_OPT_TIMER,
     /* equiv idx, value */ 2, VALUE_OPT_TIMER,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ TIMER_FLAGS, 0,
     /* last opt argumnt */ { TIMER_DFT_ARG },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ NULL,
     /* desc, NAME, name */ TIMER_DESC, TIMER_NAME, TIMER_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 3, VALUE_OPT_MAXSLEEP,
     /* equiv idx, value */ 3, VALUE_OPT_MAXSLEEP,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ MAXSLEEP_FLAGS, 0,
     /* last opt argumnt */ { MAXSLEEP_DFT_ARG },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ optionNumericVal,
     /* desc, NAME, name */ MAXSLEEP_DESC, MAXSLEEP_NAME, MAXSLEEP_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 4, VALUE_OPT_VERBOSE,
     /* equiv idx, value */ 4, VALUE_OPT_VERBOSE,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ VERBOSE_FLAGS, 0,
     /* last opt argumnt */ { NULL }, /* --verbose */
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ NULL,
     /* desc, NAME, name */ VERBOSE_DESC, VERBOSE_NAME, VERBOSE_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 5, VALUE_OPT_DECODE,
     /* equiv idx, value */ 5, VALUE_OPT_DECODE,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ DECODE_FLAGS, 0,
     /* last opt argumnt */ { NULL }, /* --decode */
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ aDecodeMustList, NULL,
     /* option proc      */ NULL,
     /* desc, NAME, name */ DECODE_DESC, DECODE_NAME, DECODE_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 6, VALUE_OPT_PRELOAD_PCAP,
     /* equiv idx, value */ 6, VALUE_OPT_PRELOAD_PCAP,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ PRELOAD_PCAP_FLAGS, 0,
     /* last opt argumnt */ { NULL }, /* --preload_pcap */
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ NULL,
     /* desc, NAME, name */ PRELOAD_PCAP_DESC, PRELOAD_PCAP_NAME, PRELOAD_PCAP_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 7, VALUE_OPT_CACHEFILE,
     /* equiv idx, value */ 7, VALUE_OPT_CACHEFILE,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ CACHEFILE_FLAGS, 0,
     /* last opt argumnt */ { NULL }, /* --cachefile */
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ aCachefileMustList, aCachefileCantList,
     /* option proc      */ NULL,
     /* desc, NAME, name */ CACHEFILE_DESC, CACHEFILE_NAME, CACHEFILE_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 8, VALUE_OPT_DUALFILE,
     /* equiv idx, value */ 8, VALUE_OPT_DUALFILE,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ DUALFILE_FLAGS, 0,
     /* last opt argumnt */ { NULL }, /* --dualfile */
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ aDualfileMustList, aDualfileCantList,
     /* option proc      */ NULL,
     /* desc, NAME, name */ DUALFILE_DESC, DUALFILE_NAME, DUALFILE_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 9, VALUE_OPT_INTF1,
     /* equiv idx, value */ 9, VALUE_OPT_INTF1,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 1, 1, 0,
     /* opt state flags  */ INTF1_FLAGS, 0,
     /* last opt argumnt */ { NULL }, /* --intf1 */
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ NULL,
     /* desc, NAME, name */ INTF1_DESC, INTF1_NAME, INTF1_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 10, VALUE_OPT_INTF2,
     /* equiv idx, value */ 10, VALUE_OPT_INTF2,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ INTF2_FLAGS, 0,
     /* last opt argumnt */ { NULL }, /* --intf2 */
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ NULL,
     /* desc, NAME, name */ INTF2_DESC, INTF2_NAME, INTF2_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 11, VALUE_OPT_LISTNICS,
     /* equiv idx, value */ 11, VALUE_OPT_LISTNICS,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ LISTNICS_FLAGS, 0,
     /* last opt argumnt */ { NULL }, /* --listnics */
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ doOptListnics,
     /* desc, NAME, name */ LISTNICS_DESC, LISTNICS_NAME, LISTNICS_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 12, VALUE_OPT_LOOP,
     /* equiv idx, value */ 12, VALUE_OPT_LOOP,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ LOOP_FLAGS, 0,
     /* last opt argumnt */ { LOOP_DFT_ARG },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ doOptLoop,
     /* desc, NAME, name */ LOOP_DESC, LOOP_NAME, LOOP_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 13, VALUE_OPT_LOOPDELAY_MS,
     /* equiv idx, value */ 13, VALUE_OPT_LOOPDELAY_MS,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ LOOPDELAY_MS_FLAGS, 0,
     /* last opt argumnt */ { LOOPDELAY_MS_DFT_ARG },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ aLoopdelay_MsMustList, NULL,
     /* option proc      */ doOptLoopdelay_Ms,
     /* desc, NAME, name */ LOOPDELAY_MS_DESC, LOOPDELAY_MS_NAME, LOOPDELAY_MS_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 14, VALUE_OPT_PKTLEN,
     /* equiv idx, value */ 14, VALUE_OPT_PKTLEN,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ PKTLEN_FLAGS, 0,
     /* last opt argumnt */ { NULL }, /* --pktlen */
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ NULL,
     /* desc, NAME, name */ PKTLEN_DESC, PKTLEN_NAME, PKTLEN_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 15, VALUE_OPT_LIMIT,
     /* equiv idx, value */ 15, VALUE_OPT_LIMIT,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ LIMIT_FLAGS, 0,
     /* last opt argumnt */ { LIMIT_DFT_ARG },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ doOptLimit,
     /* desc, NAME, name */ LIMIT_DESC, LIMIT_NAME, LIMIT_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 16, VALUE_OPT_MULTIPLIER,
     /* equiv idx, value */ 16, VALUE_OPT_MULTIPLIER,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ MULTIPLIER_FLAGS, 0,
     /* last opt argumnt */ { NULL }, /* --multiplier */
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, aMultiplierCantList,
     /* option proc      */ NULL,
     /* desc, NAME, name */ MULTIPLIER_DESC, MULTIPLIER_NAME, MULTIPLIER_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 17, VALUE_OPT_PPS,
     /* equiv idx, value */ 17, VALUE_OPT_PPS,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ PPS_FLAGS, 0,
     /* last opt argumnt */ { NULL }, /* --pps */
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, aPpsCantList,
     /* option proc      */ optionNumericVal,
     /* desc, NAME, name */ PPS_DESC, PPS_NAME, PPS_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 18, VALUE_OPT_MBPS,
     /* equiv idx, value */ 18, VALUE_OPT_MBPS,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ MBPS_FLAGS, 0,
     /* last opt argumnt */ { NULL }, /* --mbps */
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, aMbpsCantList,
     /* option proc      */ NULL,
     /* desc, NAME, name */ MBPS_DESC, MBPS_NAME, MBPS_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 19, VALUE_OPT_TOPSPEED,
     /* equiv idx, value */ 19, VALUE_OPT_TOPSPEED,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ TOPSPEED_FLAGS, 0,
     /* last opt argumnt */ { NULL }, /* --topspeed */
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, aTopspeedCantList,
     /* option proc      */ NULL,
     /* desc, NAME, name */ TOPSPEED_DESC, TOPSPEED_NAME, TOPSPEED_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 20, VALUE_OPT_ONEATATIME,
     /* equiv idx, value */ 20, VALUE_OPT_ONEATATIME,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ ONEATATIME_FLAGS, 0,
     /* last opt argumnt */ { NULL }, /* --oneatatime */
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, aOneatatimeCantList,
     /* option proc      */ NULL,
     /* desc, NAME, name */ ONEATATIME_DESC, ONEATATIME_NAME, ONEATATIME_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 21, VALUE_OPT_PPS_MULTI,
     /* equiv idx, value */ 21, VALUE_OPT_PPS_MULTI,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ PPS_MULTI_FLAGS, 0,
     /* last opt argumnt */ { PPS_MULTI_DFT_ARG },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ aPps_MultiMustList, NULL,
     /* option proc      */ doOptPps_Multi,
     /* desc, NAME, name */ PPS_MULTI_DESC, PPS_MULTI_NAME, PPS_MULTI_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 22, VALUE_OPT_UNIQUE_IP,
     /* equiv idx, value */ 22, VALUE_OPT_UNIQUE_IP,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ UNIQUE_IP_FLAGS, 0,
     /* last opt argumnt */ { NULL }, /* --unique-ip */
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ aUnique_IpMustList, NULL,
     /* option proc      */ NULL,
     /* desc, NAME, name */ UNIQUE_IP_DESC, UNIQUE_IP_NAME, UNIQUE_IP_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 23, VALUE_OPT_NETMAP,
     /* equiv idx, value */ 23, VALUE_OPT_NETMAP,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ NETMAP_FLAGS, 0,
     /* last opt argumnt */ { NULL }, /* --netmap */
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ NULL,
     /* desc, NAME, name */ NETMAP_DESC, NETMAP_NAME, NETMAP_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 24, VALUE_OPT_NM_DELAY,
     /* equiv idx, value */ 24, VALUE_OPT_NM_DELAY,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ NM_DELAY_FLAGS, 0,
     /* last opt argumnt */ { NM_DELAY_DFT_ARG },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ aNm_DelayMustList, NULL,
     /* option proc      */ optionNumericVal,
     /* desc, NAME, name */ NM_DELAY_DESC, NM_DELAY_NAME, NM_DELAY_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 25, VALUE_OPT_NO_FLOW_STATS,
     /* equiv idx, value */ 25, VALUE_OPT_NO_FLOW_STATS,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ NO_FLOW_STATS_FLAGS, 0,
     /* last opt argumnt */ { NULL }, /* --no-flow-stats */
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ NULL,
     /* desc, NAME, name */ NO_FLOW_STATS_DESC, NO_FLOW_STATS_NAME, NO_FLOW_STATS_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 26, VALUE_OPT_FLOW_EXPIRY,
     /* equiv idx, value */ 26, VALUE_OPT_FLOW_EXPIRY,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ FLOW_EXPIRY_FLAGS, 0,
     /* last opt argumnt */ { FLOW_EXPIRY_DFT_ARG },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, aFlow_ExpiryCantList,
     /* option proc      */ doOptFlow_Expiry,
     /* desc, NAME, name */ FLOW_EXPIRY_DESC, FLOW_EXPIRY_NAME, FLOW_EXPIRY_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 27, VALUE_OPT_PID,
     /* equiv idx, value */ 27, VALUE_OPT_PID,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ PID_FLAGS, 0,
     /* last opt argumnt */ { NULL }, /* --pid */
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ doOptPid,
     /* desc, NAME, name */ PID_DESC, PID_NAME, PID_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 28, VALUE_OPT_QUICK_TX,
     /* equiv idx, value */ 28, VALUE_OPT_QUICK_TX,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ QUICK_TX_FLAGS, 0,
     /* last opt argumnt */ { NULL }, /* --quick-tx */
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ NULL,
     /* desc, NAME, name */ QUICK_TX_DESC, QUICK_TX_NAME, QUICK_TX_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 29, VALUE_OPT_STATS,
     /* equiv idx, value */ 29, VALUE_OPT_STATS,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ STATS_FLAGS, 0,
     /* last opt argumnt */ { NULL }, /* --stats */
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ doOptStats,
     /* desc, NAME, name */ STATS_DESC, STATS_NAME, STATS_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 30, VALUE_OPT_VERSION,
     /* equiv idx, value */ 30, VALUE_OPT_VERSION,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ VERSION_FLAGS, 0,
     /* last opt argumnt */ { NULL }, /* --version */
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ doOptVersion,
     /* desc, NAME, name */ VERSION_DESC, VERSION_NAME, VERSION_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 31, VALUE_OPT_LESS_HELP,
     /* equiv idx, value */ 31, VALUE_OPT_LESS_HELP,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ LESS_HELP_FLAGS, 0,
     /* last opt argumnt */ { NULL }, /* --less-help */
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ doOptLess_Help,
     /* desc, NAME, name */ LESS_HELP_DESC, LESS_HELP_NAME, LESS_HELP_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ INDEX_OPT_HELP, VALUE_OPT_HELP,
     /* equiv idx value  */ NO_EQUIVALENT, VALUE_OPT_HELP,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ OPTST_IMM | OPTST_NO_INIT, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ doUsageOpt,
     /* desc, NAME, name */ HELP_DESC, NULL, HELP_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ INDEX_OPT_MORE_HELP, VALUE_OPT_MORE_HELP,
     /* equiv idx value  */ NO_EQUIVALENT, VALUE_OPT_MORE_HELP,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ MORE_HELP_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL,  NULL,
     /* option proc      */ optionPagedUsage,
     /* desc, NAME, name */ MORE_HELP_DESC, NULL, MORE_HELP_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ INDEX_OPT_SAVE_OPTS, VALUE_OPT_SAVE_OPTS,
     /* equiv idx value  */ NO_EQUIVALENT, VALUE_OPT_SAVE_OPTS,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ OPTST_SET_ARGTYPE(OPARG_TYPE_STRING)
                          | OPTST_ARG_OPTIONAL | OPTST_NO_INIT, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL,  NULL,
     /* option proc      */ NULL,
     /* desc, NAME, name */ SAVE_OPTS_DESC, NULL, SAVE_OPTS_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ INDEX_OPT_LOAD_OPTS, VALUE_OPT_LOAD_OPTS,
     /* equiv idx value  */ NO_EQUIVALENT, VALUE_OPT_LOAD_OPTS,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, NOLIMIT, 0,
     /* opt state flags  */ OPTST_SET_ARGTYPE(OPARG_TYPE_STRING)
			  | OPTST_DISABLE_IMM, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ optionLoadOpt,
     /* desc, NAME, name */ LOAD_OPTS_DESC, LOAD_OPTS_NAME, LOAD_OPTS_name,
     /* disablement strs */ NO_LOAD_OPTS_name, LOAD_OPTS_pfx }
};


/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *
 *  Define the tcpreplay Option Environment
 */
#define zPROGNAME       (tcpreplay_opt_strs+3007)
#define zUsageTitle     (tcpreplay_opt_strs+3017)
#define zRcName         (tcpreplay_opt_strs+3162)
static char const * const apzHomeList[2] = {
    tcpreplay_opt_strs+3158,
    NULL };
#define zBugsAddr       (tcpreplay_opt_strs+3175)
#define zExplain        (tcpreplay_opt_strs+3213)
#define zDetail         (tcpreplay_opt_strs+3337)
#define zFullVersion    (NULL)
/* extracted from optcode.tlib near line 350 */

#if defined(ENABLE_NLS)
# define OPTPROC_BASE OPTPROC_TRANSLATE
  static tOptionXlateProc translate_option_strings;
#else
# define OPTPROC_BASE OPTPROC_NONE
# define translate_option_strings NULL
#endif /* ENABLE_NLS */


#define tcpreplay_full_usage (NULL)

#define tcpreplay_short_usage (NULL)

#endif /* not defined __doxygen__ */

/*
 *  Create the static procedure(s) declared above.
 */
/**
 * The callout function that invokes the optionUsage function.
 *
 * @param pOptions the AutoOpts option description structure
 * @param pOptDesc the descriptor for the "help" (usage) option.
 * @noreturn
 */
static void
doUsageOpt(tOptions * pOptions, tOptDesc * pOptDesc)
{
    optionUsage(&tcpreplayOptions, TCPREPLAY_EXIT_SUCCESS);
    /* NOTREACHED */
    (void)pOptDesc;
    (void)pOptions;
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
/**
 * Code to handle the dbug option, when DEBUG is #define-d.
 *
 * @param pOptions the tcpreplay options data structure
 * @param pOptDesc the option descriptor for this option.
 */
#ifdef DEBUG
static void
doOptDbug(tOptions* pOptions, tOptDesc* pOptDesc)
{
    static struct {long rmin, rmax;} const rng[1] = {
        { 0, 5 } };
    int  ix;

    if (pOptions <= OPTPROC_EMIT_LIMIT)
        goto emit_ranges;
    optionNumericVal(pOptions, pOptDesc);

    for (ix = 0; ix < 1; ix++) {
        if (pOptDesc->optArg.argInt < rng[ix].rmin)
            continue;  /* ranges need not be ordered. */
        if (pOptDesc->optArg.argInt == rng[ix].rmin)
            return;
        if (rng[ix].rmax == LONG_MIN)
            continue;
        if (pOptDesc->optArg.argInt <= rng[ix].rmax)
            return;
    }

    option_usage_fp = stderr;

emit_ranges:
    optionShowRange(pOptions, pOptDesc, (void *)rng, 1);
}
#endif /* defined DEBUG */

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
/**
 * Code to handle the listnics option, when ENABLE_PCAP_FINDALLDEVS is #define-d.
 *
 * @param pOptions the tcpreplay options data structure
 * @param pOptDesc the option descriptor for this option.
 */
#ifdef ENABLE_PCAP_FINDALLDEVS
static void
doOptListnics(tOptions* pOptions, tOptDesc* pOptDesc)
{
    /* extracted from tcpreplay_opts.def, line 297 */

    interface_list_t *list = get_interface_list();
    list_interfaces(list);
    free(list);
    exit(0);

    (void)pOptDesc;
    (void)pOptions;
}
#endif /* defined ENABLE_PCAP_FINDALLDEVS */

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
/**
 * Code to handle the loop option.
 *
 * @param pOptions the tcpreplay options data structure
 * @param pOptDesc the option descriptor for this option.
 */
static void
doOptLoop(tOptions* pOptions, tOptDesc* pOptDesc)
{
    static struct {long rmin, rmax;} const rng[1] = {
        { 0, LONG_MAX } };
    int  ix;

    if (pOptions <= OPTPROC_EMIT_LIMIT)
        goto emit_ranges;
    optionNumericVal(pOptions, pOptDesc);

    for (ix = 0; ix < 1; ix++) {
        if (pOptDesc->optArg.argInt < rng[ix].rmin)
            continue;  /* ranges need not be ordered. */
        if (pOptDesc->optArg.argInt == rng[ix].rmin)
            return;
        if (rng[ix].rmax == LONG_MIN)
            continue;
        if (pOptDesc->optArg.argInt <= rng[ix].rmax)
            return;
    }

    option_usage_fp = stderr;

emit_ranges:
    optionShowRange(pOptions, pOptDesc, (void *)rng, 1);
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
/**
 * Code to handle the loopdelay-ms option.
 *
 * @param pOptions the tcpreplay options data structure
 * @param pOptDesc the option descriptor for this option.
 */
static void
doOptLoopdelay_Ms(tOptions* pOptions, tOptDesc* pOptDesc)
{
    static struct {long rmin, rmax;} const rng[1] = {
        { 0, LONG_MAX } };
    int  ix;

    if (pOptions <= OPTPROC_EMIT_LIMIT)
        goto emit_ranges;
    optionNumericVal(pOptions, pOptDesc);

    for (ix = 0; ix < 1; ix++) {
        if (pOptDesc->optArg.argInt < rng[ix].rmin)
            continue;  /* ranges need not be ordered. */
        if (pOptDesc->optArg.argInt == rng[ix].rmin)
            return;
        if (rng[ix].rmax == LONG_MIN)
            continue;
        if (pOptDesc->optArg.argInt <= rng[ix].rmax)
            return;
    }

    option_usage_fp = stderr;

emit_ranges:
    optionShowRange(pOptions, pOptDesc, (void *)rng, 1);
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
/**
 * Code to handle the limit option.
 *
 * @param pOptions the tcpreplay options data structure
 * @param pOptDesc the option descriptor for this option.
 */
static void
doOptLimit(tOptions* pOptions, tOptDesc* pOptDesc)
{
    static struct {long rmin, rmax;} const rng[1] = {
        { 1, LONG_MAX } };
    int  ix;

    if (pOptions <= OPTPROC_EMIT_LIMIT)
        goto emit_ranges;
    optionNumericVal(pOptions, pOptDesc);

    for (ix = 0; ix < 1; ix++) {
        if (pOptDesc->optArg.argInt < rng[ix].rmin)
            continue;  /* ranges need not be ordered. */
        if (pOptDesc->optArg.argInt == rng[ix].rmin)
            return;
        if (rng[ix].rmax == LONG_MIN)
            continue;
        if (pOptDesc->optArg.argInt <= rng[ix].rmax)
            return;
    }

    option_usage_fp = stderr;

emit_ranges:
    optionShowRange(pOptions, pOptDesc, (void *)rng, 1);
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
/**
 * Code to handle the pps-multi option.
 *
 * @param pOptions the tcpreplay options data structure
 * @param pOptDesc the option descriptor for this option.
 */
static void
doOptPps_Multi(tOptions* pOptions, tOptDesc* pOptDesc)
{
    static struct {long rmin, rmax;} const rng[1] = {
        { 1, LONG_MAX } };
    int  ix;

    if (pOptions <= OPTPROC_EMIT_LIMIT)
        goto emit_ranges;
    optionNumericVal(pOptions, pOptDesc);

    for (ix = 0; ix < 1; ix++) {
        if (pOptDesc->optArg.argInt < rng[ix].rmin)
            continue;  /* ranges need not be ordered. */
        if (pOptDesc->optArg.argInt == rng[ix].rmin)
            return;
        if (rng[ix].rmax == LONG_MIN)
            continue;
        if (pOptDesc->optArg.argInt <= rng[ix].rmax)
            return;
    }

    option_usage_fp = stderr;

emit_ranges:
    optionShowRange(pOptions, pOptDesc, (void *)rng, 1);
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
/**
 * Code to handle the flow-expiry option.
 *
 * @param pOptions the tcpreplay options data structure
 * @param pOptDesc the option descriptor for this option.
 */
static void
doOptFlow_Expiry(tOptions* pOptions, tOptDesc* pOptDesc)
{
    static struct {long rmin, rmax;} const rng[1] = {
        { 0, LONG_MAX } };
    int  ix;

    if (pOptions <= OPTPROC_EMIT_LIMIT)
        goto emit_ranges;
    optionNumericVal(pOptions, pOptDesc);

    for (ix = 0; ix < 1; ix++) {
        if (pOptDesc->optArg.argInt < rng[ix].rmin)
            continue;  /* ranges need not be ordered. */
        if (pOptDesc->optArg.argInt == rng[ix].rmin)
            return;
        if (rng[ix].rmax == LONG_MIN)
            continue;
        if (pOptDesc->optArg.argInt <= rng[ix].rmax)
            return;
    }

    option_usage_fp = stderr;

emit_ranges:
    optionShowRange(pOptions, pOptDesc, (void *)rng, 1);
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
/**
 * Code to handle the pid option.
 *
 * @param pOptions the tcpreplay options data structure
 * @param pOptDesc the option descriptor for this option.
 */
static void
doOptPid(tOptions* pOptions, tOptDesc* pOptDesc)
{
    /* extracted from tcpreplay_opts.def, line 550 */

    fprintf(stderr, "PID: %d\n", getpid());

    (void)pOptDesc;
    (void)pOptions;
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
/**
 * Code to handle the stats option.
 *
 * @param pOptions the tcpreplay options data structure
 * @param pOptDesc the option descriptor for this option.
 */
static void
doOptStats(tOptions* pOptions, tOptDesc* pOptDesc)
{
    static struct {long rmin, rmax;} const rng[1] = {
        { 1, LONG_MAX } };
    int  ix;

    if (pOptions <= OPTPROC_EMIT_LIMIT)
        goto emit_ranges;
    optionNumericVal(pOptions, pOptDesc);

    for (ix = 0; ix < 1; ix++) {
        if (pOptDesc->optArg.argInt < rng[ix].rmin)
            continue;  /* ranges need not be ordered. */
        if (pOptDesc->optArg.argInt == rng[ix].rmin)
            return;
        if (rng[ix].rmax == LONG_MIN)
            continue;
        if (pOptDesc->optArg.argInt <= rng[ix].rmax)
            return;
    }

    option_usage_fp = stderr;

emit_ranges:
    optionShowRange(pOptions, pOptDesc, (void *)rng, 1);
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
/**
 * Code to handle the version option.
 *
 * @param pOptions the tcpreplay options data structure
 * @param pOptDesc the option descriptor for this option.
 */
static void
doOptVersion(tOptions* pOptions, tOptDesc* pOptDesc)
{
    /* extracted from tcpreplay_opts.def, line 593 */

    fprintf(stderr, "tcpreplay version: %s (build %s)", VERSION, git_version());
#ifdef DEBUG
    fprintf(stderr, " (debug)");
#endif
#ifdef TIMESTAMP_TRACE
    fprintf(stderr, " (timestamp-trace)");
#endif
    fprintf(stderr, "\n");
    fprintf(stderr, "Copyright 2013-2014 by Fred Klassen <tcpreplay at appneta dot com> - AppNeta Inc.\n");
    fprintf(stderr, "Copyright 2000-2012 by Aaron Turner <aturner at synfin dot net>\n");
    fprintf(stderr, "The entire Tcpreplay Suite is licensed under the GPLv3\n");  
    fprintf(stderr, "Cache file supported: %s\n", CACHEVERSION);
#ifdef HAVE_LIBDNET
    fprintf(stderr, "Compiled against libdnet: %s\n", LIBDNET_VERSION);
#else
    fprintf(stderr, "Not compiled with libdnet.\n");
#endif
#ifdef HAVE_WINPCAP
    fprintf(stderr, "Compiled against winpcap: %s\n", get_pcap_version());
#elif defined HAVE_PF_RING_PCAP
    fprintf(stderr, "Compiled against PF_RING libpcap: %s\n", get_pcap_version());
#else
    fprintf(stderr, "Compiled against libpcap: %s\n", get_pcap_version());
#endif
#ifdef ENABLE_64BITS
    fprintf(stderr, "64 bit packet counters: enabled\n");
#else
    fprintf(stderr, "64 bit packet counters: disabled\n");
#endif
#ifdef ENABLE_VERBOSE
    fprintf(stderr, "Verbose printing via tcpdump: enabled\n");
#else
    fprintf(stderr, "Verbose printing via tcpdump: disabled\n");
#endif
#ifdef TCPREPLAY_EDIT
    fprintf(stderr, "Packet editing: enabled\n");
#else
    fprintf(stderr, "Packet editing: disabled\n");
#endif
#ifdef ENABLE_FRAGROUTE
    fprintf(stderr, "Fragroute engine: enabled\n");
#else
    fprintf(stderr, "Fragroute engine: disabled\n");
#endif
#if defined HAVE_QUICK_TX || defined HAVE_NETMAP
    fprintf(stderr, "Default injection method: %s\n", sendpacket_get_method(NULL));
#else
    fprintf(stderr, "Injection method: %s\n", sendpacket_get_method(NULL));
#endif
#ifdef HAVE_QUICK_TX
    fprintf(stderr, "Optional injection method: Quick TX\n");
#elif !defined(linux)
    fprintf(stderr, "Not compiled with Quick TX\n");
#endif
#ifdef HAVE_NETMAP
    fprintf(stderr, "Optional injection method: netmap\n");
#else
    fprintf(stderr, "Not compiled with netmap\n");
#endif
    exit(0);

    (void)pOptDesc;
    (void)pOptions;
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
/**
 * Code to handle the less-help option.
 *
 * @param pOptions the tcpreplay options data structure
 * @param pOptDesc the option descriptor for this option.
 */
static void
doOptLess_Help(tOptions* pOptions, tOptDesc* pOptDesc)
{
    /* extracted from tcpreplay_opts.def, line 665 */

    USAGE(EXIT_FAILURE);

    (void)pOptDesc;
    (void)pOptions;
}
/* extracted from optmain.tlib near line 1146 */

/**
 * The directory containing the data associated with tcpreplay.
 */
#ifndef  PKGDATADIR
# define PKGDATADIR ""
#endif

/**
 * Information about the person or institution that packaged tcpreplay
 * for the current distribution.
 */
#ifndef  WITH_PACKAGER
# define tcpreplay_packager_info NULL
#else
static char const tcpreplay_packager_info[] =
    "Packaged by " WITH_PACKAGER

# ifdef WITH_PACKAGER_VERSION
        " ("WITH_PACKAGER_VERSION")"
# endif

# ifdef WITH_PACKAGER_BUG_REPORTS
    "\nReport tcpreplay bugs to " WITH_PACKAGER_BUG_REPORTS
# endif
    "\n";
#endif
#ifndef __doxygen__

#endif /* __doxygen__ */
/**
 * The option definitions for tcpreplay.  The one structure that
 * binds them all.
 */
tOptions tcpreplayOptions = {
    OPTIONS_STRUCT_VERSION,
    0, NULL,                    /* original argc + argv    */
    ( OPTPROC_BASE
    + OPTPROC_ERRSTOP
    + OPTPROC_SHORTOPT
    + OPTPROC_LONGOPT
    + OPTPROC_NO_REQ_OPT
    + OPTPROC_ARGS_REQ
    + OPTPROC_GNUUSAGE ),
    0, NULL,                    /* current option index, current option */
    NULL,         NULL,         zPROGNAME,
    zRcName,      zCopyright,   zLicenseDescrip,
    zFullVersion, apzHomeList,  zUsageTitle,
    zExplain,     zDetail,      optDesc,
    zBugsAddr,                  /* address to send bugs to */
    NULL, NULL,                 /* extensions/saved state  */
    optionUsage, /* usage procedure */
    translate_option_strings,   /* translation procedure */
    /*
     *  Indexes to special options
     */
    { INDEX_OPT_MORE_HELP, /* more-help option index */
      INDEX_OPT_SAVE_OPTS, /* save option index */
      NO_EQUIVALENT, /* '-#' option index */
      NO_EQUIVALENT /* index of default opt */
    },
    36 /* full option count */, 32 /* user option count */,
    tcpreplay_full_usage, tcpreplay_short_usage,
    NULL, NULL,
    PKGDATADIR, tcpreplay_packager_info
};

#if ENABLE_NLS
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <autoopts/usage-txt.h>

static char* AO_gettext(char const* pz);
static void  coerce_it(void** s);

/**
 * AutoGen specific wrapper function for gettext.
 * It relies on the macro _() to convert from English to the target
 * language, then strdup-duplicates the result string.
 *
 * @param[in] pz the input text used as a lookup key.
 * @returns the translated text (if there is one),
 *   or the original text (if not).
 */
static char *
AO_gettext(char const* pz)
{
    char* pzRes;
    if (pz == NULL)
        return NULL;
    pzRes = _(pz);
    if (pzRes == pz)
        return pzRes;
    pzRes = strdup(pzRes);
    if (pzRes == NULL) {
        fputs(_("No memory for duping translated strings\n"), stderr);
        exit(TCPREPLAY_EXIT_FAILURE);
    }
    return pzRes;
}

static void coerce_it(void** s) { *s = AO_gettext(*s);
}

/**
 * Translate all the translatable strings in the tcpreplayOptions
 * structure defined above.  This is done only once.
 */
static void
translate_option_strings(void)
{
    tOptions * const pOpt = &tcpreplayOptions;

    /*
     *  Guard against re-translation.  It won't work.  The strings will have
     *  been changed by the first pass through this code.  One shot only.
     */
    if (option_usage_text.field_ct != 0) {
        /*
         *  Do the translations.  The first pointer follows the field count
         *  field.  The field count field is the size of a pointer.
         */
        tOptDesc * pOD = pOpt->pOptDesc;
        char **    ppz = (char**)(void*)&(option_usage_text);
        int        ix  = option_usage_text.field_ct;

        do {
            ppz++;
            *ppz = AO_gettext(*ppz);
        } while (--ix > 0);

        coerce_it((void*)&(pOpt->pzCopyright));
        coerce_it((void*)&(pOpt->pzCopyNotice));
        coerce_it((void*)&(pOpt->pzFullVersion));
        coerce_it((void*)&(pOpt->pzUsageTitle));
        coerce_it((void*)&(pOpt->pzExplain));
        coerce_it((void*)&(pOpt->pzDetail));
        coerce_it((void*)&(pOpt->pzPackager));
        option_usage_text.field_ct = 0;

        for (ix = pOpt->optCt; ix > 0; ix--, pOD++)
            coerce_it((void*)&(pOD->pzText));
    }

    if ((pOpt->fOptSet & OPTPROC_NXLAT_OPT_CFG) == 0) {
        tOptDesc * pOD = pOpt->pOptDesc;
        int        ix;

        for (ix = pOpt->optCt; ix > 0; ix--, pOD++) {
            coerce_it((void*)&(pOD->pz_Name));
            coerce_it((void*)&(pOD->pz_DisableName));
            coerce_it((void*)&(pOD->pz_DisablePfx));
        }
        /* prevent re-translation */
        tcpreplayOptions.fOptSet |= OPTPROC_NXLAT_OPT_CFG | OPTPROC_NXLAT_OPT;
    }
}

#endif /* ENABLE_NLS */

#ifdef  __cplusplus
}
#endif
/* tcpreplay_opts.c ends here */
