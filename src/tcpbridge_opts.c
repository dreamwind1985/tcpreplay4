/*   -*- buffer-read-only: t -*- vi: set ro:
 *  
 *  DO NOT EDIT THIS FILE   (tcpbridge_opts.c)
 *  
 *  It has been AutoGen-ed  December 17, 2014 at 03:12:41 PM by AutoGen 5.16.2
 *  From the definitions    tcpbridge_opts.def
 *  and the template file   options
 *
 * Generated from AutoOpts 36:5:11 templates.
 *
 *  AutoOpts is a copyrighted work.  This source file is not encumbered
 *  by AutoOpts licensing, but is provided under the licensing terms chosen
 *  by the tcpbridge author or copyright holder.  AutoOpts is
 *  licensed under the terms of the LGPL.  The redistributable library
 *  (``libopts'') is licensed under the terms of either the LGPL or, at the
 *  users discretion, the BSD license.  See the AutoOpts and/or libopts sources
 *  for details.
 *
 * The tcpbridge program is copyrighted and licensed
 * under the following terms:
 *
 *  Copyright (C) 2000-2014 Aaron Turner and Fred Klassen, all rights reserved.
 *  This is free software. It is licensed for use, modification and
 *  redistribution under the terms of the
 *  GNU General Public License, version 3 or later
 *      <http://gnu.org/licenses/gpl.html>
 *
 *  tcpbridge is free software: you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by the
 *  Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *  
 *  tcpbridge is distributed in the hope that it will be useful, but
 *  WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 *  See the GNU General Public License for more details.
 *  
 *  You should have received a copy of the GNU General Public License along
 *  with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#ifndef __doxygen__
#define OPTION_CODE_COMPILE 1
#include "tcpbridge_opts.h"
#include <sys/types.h>

#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>

#ifdef  __cplusplus
extern "C" {
#endif
extern FILE * option_usage_fp;

/* TRANSLATORS: choose the translation for option names wisely because you
                cannot ever change your mind. */
#define zCopyright      (tcpbridge_opt_strs+0)
#define zLicenseDescrip (tcpbridge_opt_strs+287)

/*
 *  global included definitions
 */
#include "defines.h"
#include "tcpbridge.h"
#include "common.h"
#include "config.h"
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <unistd.h>
extern tcpbridge_opt_t options;


#ifndef NULL
#  define NULL 0
#endif

/*
 *  tcpbridge option static const strings
 */
static char const tcpbridge_opt_strs[4125] =
/*     0 */ "tcpbridge (tcpbridge)\n"
            "Copyright (C) 2000-2014 Aaron Turner and Fred Klassen, all rights reserved.\n"
            "This is free software. It is licensed for use, modification and\n"
            "redistribution under the terms of the\n"
            "GNU General Public License, version 3 or later\n"
            "    <http://gnu.org/licenses/gpl.html>\n\0"
/*   287 */ "tcpbridge is free software: you can redistribute it and/or modify it under\n"
            "the terms of the GNU General Public License as published by the Free\n"
            "Software Foundation, either version 3 of the License, or (at your option)\n"
            "any later version.\n\n"
            "tcpbridge is distributed in the hope that it will be useful, but WITHOUT\n"
            "ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n"
            "FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n"
            "more details.\n\n"
            "You should have received a copy of the GNU General Public License along\n"
            "with this program.  If not, see <http://www.gnu.org/licenses/>.\n\0"
/*   894 */ ":\0"
/*   896 */ "Rewrite TCP/UDP ports\0"
/*   918 */ "PORTMAP\0"
/*   926 */ "portmap\0"
/*   934 */ "Randomize src/dst IPv4/v6 addresses w/ given seed\0"
/*   984 */ "SEED\0"
/*   989 */ "seed\0"
/*   994 */ "Rewrite IPv4/v6 addresses using pseudo-NAT\0"
/*  1037 */ "PNAT\0"
/*  1042 */ "pnat\0"
/*  1047 */ "Rewrite source IPv4/v6 addresses using pseudo-NAT\0"
/*  1097 */ "SRCIPMAP\0"
/*  1106 */ "srcipmap\0"
/*  1115 */ "Rewrite destination IPv4/v6 addresses using pseudo-NAT\0"
/*  1170 */ "DSTIPMAP\0"
/*  1179 */ "dstipmap\0"
/*  1188 */ "Rewrite IP addresses to be between two endpoints\0"
/*  1237 */ "ENDPOINTS\0"
/*  1247 */ "endpoints\0"
/*  1257 */ "Skip rewriting broadcast/multicast IPv4/v6 addresses\0"
/*  1310 */ "SKIPBROADCAST\0"
/*  1324 */ "skipbroadcast\0"
/*  1338 */ "Force recalculation of IPv4/TCP/UDP header checksums\0"
/*  1391 */ "FIXCSUM\0"
/*  1399 */ "fixcsum\0"
/*  1407 */ "Override default MTU length (1500 bytes)\0"
/*  1448 */ "MTU\0"
/*  1452 */ "mtu\0"
/*  1456 */ "Truncate packets larger then specified MTU\0"
/*  1499 */ "MTU_TRUNC\0"
/*  1509 */ "mtu-trunc\0"
/*  1519 */ "Remove Ethernet checksums (FCS) from end of frames\0"
/*  1570 */ "EFCS\0"
/*  1575 */ "efcs\0"
/*  1580 */ "Modify the IPv4/v6 TTL/Hop Limit\0"
/*  1613 */ "TTL\0"
/*  1617 */ "ttl\0"
/*  1621 */ "Set the IPv4 TOS/DiffServ/ECN byte\0"
/*  1656 */ "TOS\0"
/*  1660 */ "tos\0"
/*  1664 */ "Set the IPv6 Traffic Class byte\0"
/*  1696 */ "TCLASS\0"
/*  1703 */ "tclass\0"
/*  1710 */ "Set the IPv6 Flow Label\0"
/*  1734 */ "FLOWLABEL\0"
/*  1744 */ "flowlabel\0"
/*  1754 */ "Pad or truncate packet data to match header length\0"
/*  1805 */ "FIXLEN\0"
/*  1812 */ "fixlen\0"
/*  1819 */ "Skip rewriting broadcast/multicast Layer 2 addresses\0"
/*  1872 */ "SKIPL2BROADCAST\0"
/*  1888 */ "skipl2broadcast\0"
/*  1904 */ "Override output DLT encapsulation\0"
/*  1938 */ "DLT\0"
/*  1942 */ "dlt\0"
/*  1946 */ "Override destination ethernet MAC addresses\0"
/*  1990 */ "ENET_DMAC\0"
/*  2000 */ "enet-dmac\0"
/*  2010 */ "Override source ethernet MAC addresses\0"
/*  2049 */ "ENET_SMAC\0"
/*  2059 */ "enet-smac\0"
/*  2069 */ "Specify ethernet 802.1q VLAN tag mode\0"
/*  2107 */ "ENET_VLAN\0"
/*  2117 */ "enet-vlan\0"
/*  2127 */ "Specify the new ethernet 802.1q VLAN tag value\0"
/*  2174 */ "ENET_VLAN_TAG\0"
/*  2188 */ "enet-vlan-tag\0"
/*  2202 */ "Specify the ethernet 802.1q VLAN CFI value\0"
/*  2245 */ "ENET_VLAN_CFI\0"
/*  2259 */ "enet-vlan-cfi\0"
/*  2273 */ "Specify the ethernet 802.1q VLAN priority\0"
/*  2315 */ "ENET_VLAN_PRI\0"
/*  2329 */ "enet-vlan-pri\0"
/*  2343 */ "Specify HDLC control value\0"
/*  2370 */ "HDLC_CONTROL\0"
/*  2383 */ "hdlc-control\0"
/*  2396 */ "Specify HDLC address\0"
/*  2417 */ "HDLC_ADDRESS\0"
/*  2430 */ "hdlc-address\0"
/*  2443 */ "Set output file DLT type\0"
/*  2468 */ "USER_DLT\0"
/*  2477 */ "user-dlt\0"
/*  2486 */ "Rewrite Data-Link layer with user specified data\0"
/*  2535 */ "USER_DLINK\0"
/*  2546 */ "user-dlink\0"
/*  2557 */ "Enable debugging output\0"
/*  2581 */ "DBUG\0"
/*  2586 */ "dbug\0"
/*  2591 */ "Primary interface (listen in uni-directional mode)\0"
/*  2642 */ "INTF1\0"
/*  2648 */ "intf1\0"
/*  2654 */ "Secondary interface (send in uni-directional mode)\0"
/*  2705 */ "INTF2\0"
/*  2711 */ "intf2\0"
/*  2717 */ "Send and receive in only one direction\0"
/*  2756 */ "UNIDIR\0"
/*  2763 */ "unidir\0"
/*  2770 */ "List available network interfaces and exit\0"
/*  2813 */ "LISTNICS\0"
/*  2822 */ "listnics\0"
/*  2831 */ "Limit the number of packets to send\0"
/*  2867 */ "LIMIT\0"
/*  2873 */ "limit\0"
/*  2879 */ "MAC addresses of local NIC's\0"
/*  2908 */ "MAC\0"
/*  2912 */ "mac\0"
/*  2916 */ "Include only packets matching rule\0"
/*  2951 */ "INCLUDE\0"
/*  2959 */ "include\0"
/*  2967 */ "Exclude any packet matching this rule\0"
/*  3005 */ "EXCLUDE\0"
/*  3013 */ "exclude\0"
/*  3021 */ "Print the PID of tcpbridge at startup\0"
/*  3059 */ "PID\0"
/*  3063 */ "pid\0"
/*  3067 */ "Print decoded packets via tcpdump to STDOUT\0"
/*  3111 */ "VERBOSE\0"
/*  3119 */ "verbose\0"
/*  3127 */ "Arguments passed to tcpdump decoder\0"
/*  3163 */ "DECODE\0"
/*  3170 */ "decode\0"
/*  3177 */ "Print version information\0"
/*  3203 */ "VERSION\0"
/*  3211 */ "version\0"
/*  3219 */ "Display less usage information and exit\0"
/*  3259 */ "LESS_HELP\0"
/*  3269 */ "less-help\0"
/*  3279 */ "Display extended usage information and exit\0"
/*  3323 */ "help\0"
/*  3328 */ "Extended usage information passed thru pager\0"
/*  3373 */ "more-help\0"
/*  3383 */ "Save the option state to a config file\0"
/*  3422 */ "save-opts\0"
/*  3432 */ "Load options from a config file\0"
/*  3464 */ "LOAD_OPTS\0"
/*  3474 */ "no-load-opts\0"
/*  3487 */ "no\0"
/*  3490 */ "TCPBRIDGE\0"
/*  3500 */ "tcpbridge (tcpbridge) - Bridge network traffic across two interfaces\n"
            "USAGE:  %s [ -<flag> [<val>] | --<name>[{=| }<val>] ]...\n\0"
/*  3627 */ "$$/\0"
/*  3631 */ ".tcpbridgerc\0"
/*  3644 */ "tcpreplay-users@lists.sourceforge.net\0"
/*  3682 */ "\n"
            "tcpbridge is a tool for selectively briding network traffic across two\n"
            "interfaces and optionally modifying the packets in betweeen\n\0"
/*  3815 */ "\n"
            "The basic operation of tcpbridge is to be a network bridge between two\n"
            "subnets.  All packets received on one interface are sent via the other.\n\n"
            "Optionally, packets can be edited in a variety of ways according to your\n"
            "needs.\n\n"
            "For more details, please see the Tcpreplay Manual at:\n"
            "http://tcpreplay.appneta.com\n";

/*
 *  tcpedit option description:
 */
#define TCPEDIT_DESC      (tcpbridge_opt_strs+894)
#define TCPEDIT_FLAGS     (OPTST_DOCUMENT | OPTST_NO_INIT)

/*
 *  portmap option description:
 */
#define PORTMAP_DESC      (tcpbridge_opt_strs+896)
#define PORTMAP_NAME      (tcpbridge_opt_strs+918)
#define PORTMAP_name      (tcpbridge_opt_strs+926)
#define PORTMAP_FLAGS     (OPTST_DISABLED | OPTST_STACKED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_STRING))

/*
 *  seed option description:
 */
#define SEED_DESC      (tcpbridge_opt_strs+934)
#define SEED_NAME      (tcpbridge_opt_strs+984)
#define SEED_name      (tcpbridge_opt_strs+989)
#define SEED_FLAGS     (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_NUMERIC))

/*
 *  pnat option description with
 *  "Must also have options" and "Incompatible options":
 */
#define PNAT_DESC      (tcpbridge_opt_strs+994)
#define PNAT_NAME      (tcpbridge_opt_strs+1037)
#define PNAT_name      (tcpbridge_opt_strs+1042)
static int const aPnatCantList[] = {
    INDEX_OPT_SRCIPMAP, NO_EQUIVALENT };
#define PNAT_FLAGS     (OPTST_DISABLED | OPTST_STACKED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_STRING))

/*
 *  srcipmap option description with
 *  "Must also have options" and "Incompatible options":
 */
#define SRCIPMAP_DESC      (tcpbridge_opt_strs+1047)
#define SRCIPMAP_NAME      (tcpbridge_opt_strs+1097)
#define SRCIPMAP_name      (tcpbridge_opt_strs+1106)
static int const aSrcipmapCantList[] = {
    INDEX_OPT_PNAT, NO_EQUIVALENT };
#define SRCIPMAP_FLAGS     (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_STRING))

/*
 *  dstipmap option description with
 *  "Must also have options" and "Incompatible options":
 */
#define DSTIPMAP_DESC      (tcpbridge_opt_strs+1115)
#define DSTIPMAP_NAME      (tcpbridge_opt_strs+1170)
#define DSTIPMAP_name      (tcpbridge_opt_strs+1179)
static int const aDstipmapCantList[] = {
    INDEX_OPT_PNAT, NO_EQUIVALENT };
#define DSTIPMAP_FLAGS     (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_STRING))

/*
 *  endpoints option description with
 *  "Must also have options" and "Incompatible options":
 */
#ifdef HAVE_CACHEFILE_SUPPORT
#define ENDPOINTS_DESC      (tcpbridge_opt_strs+1188)
#define ENDPOINTS_NAME      (tcpbridge_opt_strs+1237)
#define ENDPOINTS_name      (tcpbridge_opt_strs+1247)
static int const aEndpointsMustList[] = {
    INDEX_OPT_CACHEFILE, NO_EQUIVALENT };
#define ENDPOINTS_FLAGS     (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_STRING))

#else   /* disable endpoints */
#define ENDPOINTS_FLAGS     (OPTST_OMITTED | OPTST_NO_INIT)
#define aEndpointsMustList   NULL
#define ENDPOINTS_NAME      NULL
#define ENDPOINTS_DESC      NULL
#define ENDPOINTS_name      NULL
#endif  /* HAVE_CACHEFILE_SUPPORT */

/*
 *  skipbroadcast option description:
 */
#define SKIPBROADCAST_DESC      (tcpbridge_opt_strs+1257)
#define SKIPBROADCAST_NAME      (tcpbridge_opt_strs+1310)
#define SKIPBROADCAST_name      (tcpbridge_opt_strs+1324)
#define SKIPBROADCAST_FLAGS     (OPTST_DISABLED)

/*
 *  fixcsum option description:
 */
#define FIXCSUM_DESC      (tcpbridge_opt_strs+1338)
#define FIXCSUM_NAME      (tcpbridge_opt_strs+1391)
#define FIXCSUM_name      (tcpbridge_opt_strs+1399)
#define FIXCSUM_FLAGS     (OPTST_DISABLED)

/*
 *  mtu option description:
 */
#define MTU_DESC      (tcpbridge_opt_strs+1407)
#define MTU_NAME      (tcpbridge_opt_strs+1448)
#define MTU_name      (tcpbridge_opt_strs+1452)
#define MTU_FLAGS     (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_NUMERIC))

/*
 *  mtu-trunc option description:
 */
#define MTU_TRUNC_DESC      (tcpbridge_opt_strs+1456)
#define MTU_TRUNC_NAME      (tcpbridge_opt_strs+1499)
#define MTU_TRUNC_name      (tcpbridge_opt_strs+1509)
#define MTU_TRUNC_FLAGS     (OPTST_DISABLED)

/*
 *  efcs option description:
 */
#define EFCS_DESC      (tcpbridge_opt_strs+1519)
#define EFCS_NAME      (tcpbridge_opt_strs+1570)
#define EFCS_name      (tcpbridge_opt_strs+1575)
#define EFCS_FLAGS     (OPTST_DISABLED)

/*
 *  ttl option description:
 */
#define TTL_DESC      (tcpbridge_opt_strs+1580)
#define TTL_NAME      (tcpbridge_opt_strs+1613)
#define TTL_name      (tcpbridge_opt_strs+1617)
#define TTL_FLAGS     (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_STRING))

/*
 *  tos option description:
 */
#define TOS_DESC      (tcpbridge_opt_strs+1621)
#define TOS_NAME      (tcpbridge_opt_strs+1656)
#define TOS_name      (tcpbridge_opt_strs+1660)
#define TOS_FLAGS     (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_NUMERIC))

/*
 *  tclass option description:
 */
#define TCLASS_DESC      (tcpbridge_opt_strs+1664)
#define TCLASS_NAME      (tcpbridge_opt_strs+1696)
#define TCLASS_name      (tcpbridge_opt_strs+1703)
#define TCLASS_FLAGS     (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_NUMERIC))

/*
 *  flowlabel option description:
 */
#define FLOWLABEL_DESC      (tcpbridge_opt_strs+1710)
#define FLOWLABEL_NAME      (tcpbridge_opt_strs+1734)
#define FLOWLABEL_name      (tcpbridge_opt_strs+1744)
#define FLOWLABEL_FLAGS     (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_NUMERIC))

/*
 *  fixlen option description:
 */
#define FIXLEN_DESC      (tcpbridge_opt_strs+1754)
#define FIXLEN_NAME      (tcpbridge_opt_strs+1805)
#define FIXLEN_name      (tcpbridge_opt_strs+1812)
#define FIXLEN_FLAGS     (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_STRING))

/*
 *  skipl2broadcast option description:
 */
#define SKIPL2BROADCAST_DESC      (tcpbridge_opt_strs+1819)
#define SKIPL2BROADCAST_NAME      (tcpbridge_opt_strs+1872)
#define SKIPL2BROADCAST_name      (tcpbridge_opt_strs+1888)
#define SKIPL2BROADCAST_FLAGS     (OPTST_DISABLED)

/*
 *  dlt option description:
 */
#define DLT_DESC      (tcpbridge_opt_strs+1904)
#define DLT_NAME      (tcpbridge_opt_strs+1938)
#define DLT_name      (tcpbridge_opt_strs+1942)
#define DLT_FLAGS     (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_STRING))

/*
 *  enet-dmac option description:
 */
#define ENET_DMAC_DESC      (tcpbridge_opt_strs+1946)
#define ENET_DMAC_NAME      (tcpbridge_opt_strs+1990)
#define ENET_DMAC_name      (tcpbridge_opt_strs+2000)
#define ENET_DMAC_FLAGS     (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_STRING))

/*
 *  enet-smac option description:
 */
#define ENET_SMAC_DESC      (tcpbridge_opt_strs+2010)
#define ENET_SMAC_NAME      (tcpbridge_opt_strs+2049)
#define ENET_SMAC_name      (tcpbridge_opt_strs+2059)
#define ENET_SMAC_FLAGS     (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_STRING))

/*
 *  enet-vlan option description:
 */
#define ENET_VLAN_DESC      (tcpbridge_opt_strs+2069)
#define ENET_VLAN_NAME      (tcpbridge_opt_strs+2107)
#define ENET_VLAN_name      (tcpbridge_opt_strs+2117)
#define ENET_VLAN_FLAGS     (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_STRING))

/*
 *  enet-vlan-tag option description with
 *  "Must also have options" and "Incompatible options":
 */
#define ENET_VLAN_TAG_DESC      (tcpbridge_opt_strs+2127)
#define ENET_VLAN_TAG_NAME      (tcpbridge_opt_strs+2174)
#define ENET_VLAN_TAG_name      (tcpbridge_opt_strs+2188)
static int const aEnet_Vlan_TagMustList[] = {
    INDEX_OPT_ENET_VLAN, NO_EQUIVALENT };
#define ENET_VLAN_TAG_FLAGS     (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_NUMERIC))

/*
 *  enet-vlan-cfi option description with
 *  "Must also have options" and "Incompatible options":
 */
#define ENET_VLAN_CFI_DESC      (tcpbridge_opt_strs+2202)
#define ENET_VLAN_CFI_NAME      (tcpbridge_opt_strs+2245)
#define ENET_VLAN_CFI_name      (tcpbridge_opt_strs+2259)
static int const aEnet_Vlan_CfiMustList[] = {
    INDEX_OPT_ENET_VLAN, NO_EQUIVALENT };
#define ENET_VLAN_CFI_FLAGS     (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_NUMERIC))

/*
 *  enet-vlan-pri option description with
 *  "Must also have options" and "Incompatible options":
 */
#define ENET_VLAN_PRI_DESC      (tcpbridge_opt_strs+2273)
#define ENET_VLAN_PRI_NAME      (tcpbridge_opt_strs+2315)
#define ENET_VLAN_PRI_name      (tcpbridge_opt_strs+2329)
static int const aEnet_Vlan_PriMustList[] = {
    INDEX_OPT_ENET_VLAN, NO_EQUIVALENT };
#define ENET_VLAN_PRI_FLAGS     (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_NUMERIC))

/*
 *  hdlc-control option description:
 */
#define HDLC_CONTROL_DESC      (tcpbridge_opt_strs+2343)
#define HDLC_CONTROL_NAME      (tcpbridge_opt_strs+2370)
#define HDLC_CONTROL_name      (tcpbridge_opt_strs+2383)
#define HDLC_CONTROL_FLAGS     (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_NUMERIC))

/*
 *  hdlc-address option description:
 */
#define HDLC_ADDRESS_DESC      (tcpbridge_opt_strs+2396)
#define HDLC_ADDRESS_NAME      (tcpbridge_opt_strs+2417)
#define HDLC_ADDRESS_name      (tcpbridge_opt_strs+2430)
#define HDLC_ADDRESS_FLAGS     (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_NUMERIC))

/*
 *  user-dlt option description:
 */
#define USER_DLT_DESC      (tcpbridge_opt_strs+2443)
#define USER_DLT_NAME      (tcpbridge_opt_strs+2468)
#define USER_DLT_name      (tcpbridge_opt_strs+2477)
#define USER_DLT_FLAGS     (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_NUMERIC))

/*
 *  user-dlink option description:
 */
#define USER_DLINK_DESC      (tcpbridge_opt_strs+2486)
#define USER_DLINK_NAME      (tcpbridge_opt_strs+2535)
#define USER_DLINK_name      (tcpbridge_opt_strs+2546)
#define USER_DLINK_FLAGS     (OPTST_DISABLED | OPTST_STACKED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_STRING))

/*
 *  dbug option description:
 */
#ifdef DEBUG
#define DBUG_DESC      (tcpbridge_opt_strs+2557)
#define DBUG_NAME      (tcpbridge_opt_strs+2581)
#define DBUG_name      (tcpbridge_opt_strs+2586)
#define DBUG_DFT_ARG   ((char const*)0)
#define DBUG_FLAGS     (OPTST_DISABLED | OPTST_IMM \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_NUMERIC))

#else   /* disable dbug */
#define DBUG_FLAGS     (OPTST_OMITTED | OPTST_NO_INIT)
#define DBUG_DFT_ARG   NULL
#define DBUG_NAME      NULL
#define DBUG_DESC      NULL
#define DBUG_name      NULL
#endif  /* DEBUG */

/*
 *  intf1 option description:
 */
#define INTF1_DESC      (tcpbridge_opt_strs+2591)
#define INTF1_NAME      (tcpbridge_opt_strs+2642)
#define INTF1_name      (tcpbridge_opt_strs+2648)
#define INTF1_FLAGS     (OPTST_DISABLED | OPTST_MUST_SET \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_STRING))

/*
 *  intf2 option description:
 */
#define INTF2_DESC      (tcpbridge_opt_strs+2654)
#define INTF2_NAME      (tcpbridge_opt_strs+2705)
#define INTF2_name      (tcpbridge_opt_strs+2711)
#define INTF2_FLAGS     (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_STRING))

/*
 *  unidir option description:
 */
#define UNIDIR_DESC      (tcpbridge_opt_strs+2717)
#define UNIDIR_NAME      (tcpbridge_opt_strs+2756)
#define UNIDIR_name      (tcpbridge_opt_strs+2763)
#define UNIDIR_FLAGS     (OPTST_DISABLED)

/*
 *  listnics option description:
 */
#ifdef ENABLE_PCAP_FINDALLDEVS
#define LISTNICS_DESC      (tcpbridge_opt_strs+2770)
#define LISTNICS_NAME      (tcpbridge_opt_strs+2813)
#define LISTNICS_name      (tcpbridge_opt_strs+2822)
#define LISTNICS_FLAGS     (OPTST_DISABLED | OPTST_IMM)

#else   /* disable listnics */
#define LISTNICS_FLAGS     (OPTST_OMITTED | OPTST_NO_INIT)
#define LISTNICS_NAME      NULL
#define LISTNICS_DESC      NULL
#define LISTNICS_name      NULL
#endif  /* ENABLE_PCAP_FINDALLDEVS */

/*
 *  limit option description:
 */
#define LIMIT_DESC      (tcpbridge_opt_strs+2831)
#define LIMIT_NAME      (tcpbridge_opt_strs+2867)
#define LIMIT_name      (tcpbridge_opt_strs+2873)
#define LIMIT_DFT_ARG   ((char const*)-1)
#define LIMIT_FLAGS     (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_NUMERIC))

/*
 *  mac option description:
 */
#define MAC_DESC      (tcpbridge_opt_strs+2879)
#define MAC_NAME      (tcpbridge_opt_strs+2908)
#define MAC_name      (tcpbridge_opt_strs+2912)
#define MAC_FLAGS     (OPTST_DISABLED | OPTST_STACKED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_STRING))

/*
 *  include option description with
 *  "Must also have options" and "Incompatible options":
 */
#define INCLUDE_DESC      (tcpbridge_opt_strs+2916)
#define INCLUDE_NAME      (tcpbridge_opt_strs+2951)
#define INCLUDE_name      (tcpbridge_opt_strs+2959)
static int const aIncludeCantList[] = {
    INDEX_OPT_EXCLUDE, NO_EQUIVALENT };
#define INCLUDE_FLAGS     (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_STRING))

/*
 *  exclude option description with
 *  "Must also have options" and "Incompatible options":
 */
#define EXCLUDE_DESC      (tcpbridge_opt_strs+2967)
#define EXCLUDE_NAME      (tcpbridge_opt_strs+3005)
#define EXCLUDE_name      (tcpbridge_opt_strs+3013)
static int const aExcludeCantList[] = {
    INDEX_OPT_INCLUDE, NO_EQUIVALENT };
#define EXCLUDE_FLAGS     (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_STRING))

/*
 *  pid option description:
 */
#define PID_DESC      (tcpbridge_opt_strs+3021)
#define PID_NAME      (tcpbridge_opt_strs+3059)
#define PID_name      (tcpbridge_opt_strs+3063)
#define PID_FLAGS     (OPTST_DISABLED)

/*
 *  verbose option description:
 */
#ifdef ENABLE_VERBOSE
#define VERBOSE_DESC      (tcpbridge_opt_strs+3067)
#define VERBOSE_NAME      (tcpbridge_opt_strs+3111)
#define VERBOSE_name      (tcpbridge_opt_strs+3119)
#define VERBOSE_FLAGS     (OPTST_DISABLED | OPTST_IMM)

#else   /* disable verbose */
#define VERBOSE_FLAGS     (OPTST_OMITTED | OPTST_NO_INIT)
#define VERBOSE_NAME      NULL
#define VERBOSE_DESC      NULL
#define VERBOSE_name      NULL
#endif  /* ENABLE_VERBOSE */

/*
 *  decode option description with
 *  "Must also have options" and "Incompatible options":
 */
#ifdef ENABLE_VERBOSE
#define DECODE_DESC      (tcpbridge_opt_strs+3127)
#define DECODE_NAME      (tcpbridge_opt_strs+3163)
#define DECODE_name      (tcpbridge_opt_strs+3170)
static int const aDecodeMustList[] = {
    INDEX_OPT_VERBOSE, NO_EQUIVALENT };
#define DECODE_FLAGS     (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_STRING))

#else   /* disable decode */
#define DECODE_FLAGS     (OPTST_OMITTED | OPTST_NO_INIT)
#define aDecodeMustList   NULL
#define DECODE_NAME      NULL
#define DECODE_DESC      NULL
#define DECODE_name      NULL
#endif  /* ENABLE_VERBOSE */

/*
 *  version option description:
 */
#define VERSION_DESC      (tcpbridge_opt_strs+3177)
#define VERSION_NAME      (tcpbridge_opt_strs+3203)
#define VERSION_name      (tcpbridge_opt_strs+3211)
#define VERSION_FLAGS     (OPTST_DISABLED)

/*
 *  less-help option description:
 */
#define LESS_HELP_DESC      (tcpbridge_opt_strs+3219)
#define LESS_HELP_NAME      (tcpbridge_opt_strs+3259)
#define LESS_HELP_name      (tcpbridge_opt_strs+3269)
#define LESS_HELP_FLAGS     (OPTST_DISABLED | OPTST_IMM)

/*
 *  Help/More_Help option descriptions:
 */
#define HELP_DESC       (tcpbridge_opt_strs+3279)
#define HELP_name       (tcpbridge_opt_strs+3323)
#ifdef HAVE_WORKING_FORK
#define MORE_HELP_DESC  (tcpbridge_opt_strs+3328)
#define MORE_HELP_name  (tcpbridge_opt_strs+3373)
#define MORE_HELP_FLAGS (OPTST_IMM | OPTST_NO_INIT)
#else
#define MORE_HELP_DESC  NULL
#define MORE_HELP_name  NULL
#define MORE_HELP_FLAGS (OPTST_OMITTED | OPTST_NO_INIT)
#endif
#define SAVE_OPTS_DESC  (tcpbridge_opt_strs+3383)
#define SAVE_OPTS_name  (tcpbridge_opt_strs+3422)
#define LOAD_OPTS_DESC     (tcpbridge_opt_strs+3432)
#define LOAD_OPTS_NAME     (tcpbridge_opt_strs+3464)
#define NO_LOAD_OPTS_name  (tcpbridge_opt_strs+3474)
#define LOAD_OPTS_pfx      (tcpbridge_opt_strs+3487)
#define LOAD_OPTS_name     (NO_LOAD_OPTS_name + 3)
/*
 *  Declare option callback procedures
 */
#ifdef DEBUG
  static tOptProc doOptDbug;
#else /* not DEBUG */
# define doOptDbug NULL
#endif /* def/not DEBUG */
#ifdef ENABLE_PCAP_FINDALLDEVS
  static tOptProc doOptListnics;
#else /* not ENABLE_PCAP_FINDALLDEVS */
# define doOptListnics NULL
#endif /* def/not ENABLE_PCAP_FINDALLDEVS */
extern tOptProc
    optionBooleanVal,   optionNestedVal,    optionNumericVal,
    optionPagedUsage,   optionPrintVersion, optionResetOpt,
    optionStackArg,     optionTimeDate,     optionTimeVal,
    optionUnstackArg,   optionVendorOption;
static tOptProc
    doOptEnet_Vlan_Cfi, doOptEnet_Vlan_Pri, doOptEnet_Vlan_Tag,
    doOptExclude,       doOptFlowlabel,     doOptInclude,
    doOptLess_Help,     doOptLimit,         doOptMtu,
    doOptPid,           doOptTclass,        doOptTos,
    doOptVersion,       doUsageOpt;

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
/**
 *  Define the tcpbridge Option Descriptions.
 * This is an array of OPTION_CT entries, one for each
 * option that the tcpbridge program responds to.
 */
static tOptDesc optDesc[OPTION_CT] = {
  {  /* entry idx, value */ 0, 0,
     /* equiv idx, value */ 0, 0,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 0, 0,
     /* opt state flags  */ TCPEDIT_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ NULL,
     /* desc, NAME, name */ TCPEDIT_DESC, NULL, NULL,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 1, VALUE_OPT_PORTMAP,
     /* equiv idx, value */ 1, VALUE_OPT_PORTMAP,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, -1, 0,
     /* opt state flags  */ PORTMAP_FLAGS, 0,
     /* last opt argumnt */ { NULL }, /* --portmap */
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ optionStackArg,
     /* desc, NAME, name */ PORTMAP_DESC, PORTMAP_NAME, PORTMAP_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 2, VALUE_OPT_SEED,
     /* equiv idx, value */ 2, VALUE_OPT_SEED,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ SEED_FLAGS, 0,
     /* last opt argumnt */ { NULL }, /* --seed */
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ optionNumericVal,
     /* desc, NAME, name */ SEED_DESC, SEED_NAME, SEED_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 3, VALUE_OPT_PNAT,
     /* equiv idx, value */ 3, VALUE_OPT_PNAT,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 2, 0,
     /* opt state flags  */ PNAT_FLAGS, 0,
     /* last opt argumnt */ { NULL }, /* --pnat */
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, aPnatCantList,
     /* option proc      */ optionStackArg,
     /* desc, NAME, name */ PNAT_DESC, PNAT_NAME, PNAT_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 4, VALUE_OPT_SRCIPMAP,
     /* equiv idx, value */ 4, VALUE_OPT_SRCIPMAP,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ SRCIPMAP_FLAGS, 0,
     /* last opt argumnt */ { NULL }, /* --srcipmap */
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, aSrcipmapCantList,
     /* option proc      */ NULL,
     /* desc, NAME, name */ SRCIPMAP_DESC, SRCIPMAP_NAME, SRCIPMAP_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 5, VALUE_OPT_DSTIPMAP,
     /* equiv idx, value */ 5, VALUE_OPT_DSTIPMAP,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ DSTIPMAP_FLAGS, 0,
     /* last opt argumnt */ { NULL }, /* --dstipmap */
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, aDstipmapCantList,
     /* option proc      */ NULL,
     /* desc, NAME, name */ DSTIPMAP_DESC, DSTIPMAP_NAME, DSTIPMAP_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 6, VALUE_OPT_ENDPOINTS,
     /* equiv idx, value */ 6, VALUE_OPT_ENDPOINTS,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ ENDPOINTS_FLAGS, 0,
     /* last opt argumnt */ { NULL }, /* --endpoints */
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ aEndpointsMustList, NULL,
     /* option proc      */ NULL,
     /* desc, NAME, name */ ENDPOINTS_DESC, ENDPOINTS_NAME, ENDPOINTS_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 7, VALUE_OPT_SKIPBROADCAST,
     /* equiv idx, value */ 7, VALUE_OPT_SKIPBROADCAST,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ SKIPBROADCAST_FLAGS, 0,
     /* last opt argumnt */ { NULL }, /* --skipbroadcast */
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ NULL,
     /* desc, NAME, name */ SKIPBROADCAST_DESC, SKIPBROADCAST_NAME, SKIPBROADCAST_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 8, VALUE_OPT_FIXCSUM,
     /* equiv idx, value */ 8, VALUE_OPT_FIXCSUM,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ FIXCSUM_FLAGS, 0,
     /* last opt argumnt */ { NULL }, /* --fixcsum */
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ NULL,
     /* desc, NAME, name */ FIXCSUM_DESC, FIXCSUM_NAME, FIXCSUM_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 9, VALUE_OPT_MTU,
     /* equiv idx, value */ 9, VALUE_OPT_MTU,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ MTU_FLAGS, 0,
     /* last opt argumnt */ { NULL }, /* --mtu */
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ doOptMtu,
     /* desc, NAME, name */ MTU_DESC, MTU_NAME, MTU_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 10, VALUE_OPT_MTU_TRUNC,
     /* equiv idx, value */ 10, VALUE_OPT_MTU_TRUNC,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ MTU_TRUNC_FLAGS, 0,
     /* last opt argumnt */ { NULL }, /* --mtu-trunc */
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ NULL,
     /* desc, NAME, name */ MTU_TRUNC_DESC, MTU_TRUNC_NAME, MTU_TRUNC_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 11, VALUE_OPT_EFCS,
     /* equiv idx, value */ 11, VALUE_OPT_EFCS,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ EFCS_FLAGS, 0,
     /* last opt argumnt */ { NULL }, /* --efcs */
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ NULL,
     /* desc, NAME, name */ EFCS_DESC, EFCS_NAME, EFCS_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 12, VALUE_OPT_TTL,
     /* equiv idx, value */ 12, VALUE_OPT_TTL,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ TTL_FLAGS, 0,
     /* last opt argumnt */ { NULL }, /* --ttl */
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ NULL,
     /* desc, NAME, name */ TTL_DESC, TTL_NAME, TTL_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 13, VALUE_OPT_TOS,
     /* equiv idx, value */ 13, VALUE_OPT_TOS,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ TOS_FLAGS, 0,
     /* last opt argumnt */ { NULL }, /* --tos */
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ doOptTos,
     /* desc, NAME, name */ TOS_DESC, TOS_NAME, TOS_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 14, VALUE_OPT_TCLASS,
     /* equiv idx, value */ 14, VALUE_OPT_TCLASS,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ TCLASS_FLAGS, 0,
     /* last opt argumnt */ { NULL }, /* --tclass */
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ doOptTclass,
     /* desc, NAME, name */ TCLASS_DESC, TCLASS_NAME, TCLASS_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 15, VALUE_OPT_FLOWLABEL,
     /* equiv idx, value */ 15, VALUE_OPT_FLOWLABEL,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ FLOWLABEL_FLAGS, 0,
     /* last opt argumnt */ { NULL }, /* --flowlabel */
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ doOptFlowlabel,
     /* desc, NAME, name */ FLOWLABEL_DESC, FLOWLABEL_NAME, FLOWLABEL_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 16, VALUE_OPT_FIXLEN,
     /* equiv idx, value */ 16, VALUE_OPT_FIXLEN,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ FIXLEN_FLAGS, 0,
     /* last opt argumnt */ { NULL }, /* --fixlen */
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ NULL,
     /* desc, NAME, name */ FIXLEN_DESC, FIXLEN_NAME, FIXLEN_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 17, VALUE_OPT_SKIPL2BROADCAST,
     /* equiv idx, value */ 17, VALUE_OPT_SKIPL2BROADCAST,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ SKIPL2BROADCAST_FLAGS, 0,
     /* last opt argumnt */ { NULL }, /* --skipl2broadcast */
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ NULL,
     /* desc, NAME, name */ SKIPL2BROADCAST_DESC, SKIPL2BROADCAST_NAME, SKIPL2BROADCAST_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 18, VALUE_OPT_DLT,
     /* equiv idx, value */ 18, VALUE_OPT_DLT,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ DLT_FLAGS, 0,
     /* last opt argumnt */ { NULL }, /* --dlt */
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ NULL,
     /* desc, NAME, name */ DLT_DESC, DLT_NAME, DLT_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 19, VALUE_OPT_ENET_DMAC,
     /* equiv idx, value */ 19, VALUE_OPT_ENET_DMAC,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ ENET_DMAC_FLAGS, 0,
     /* last opt argumnt */ { NULL }, /* --enet-dmac */
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ NULL,
     /* desc, NAME, name */ ENET_DMAC_DESC, ENET_DMAC_NAME, ENET_DMAC_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 20, VALUE_OPT_ENET_SMAC,
     /* equiv idx, value */ 20, VALUE_OPT_ENET_SMAC,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ ENET_SMAC_FLAGS, 0,
     /* last opt argumnt */ { NULL }, /* --enet-smac */
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ NULL,
     /* desc, NAME, name */ ENET_SMAC_DESC, ENET_SMAC_NAME, ENET_SMAC_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 21, VALUE_OPT_ENET_VLAN,
     /* equiv idx, value */ 21, VALUE_OPT_ENET_VLAN,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ ENET_VLAN_FLAGS, 0,
     /* last opt argumnt */ { NULL }, /* --enet-vlan */
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ NULL,
     /* desc, NAME, name */ ENET_VLAN_DESC, ENET_VLAN_NAME, ENET_VLAN_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 22, VALUE_OPT_ENET_VLAN_TAG,
     /* equiv idx, value */ 22, VALUE_OPT_ENET_VLAN_TAG,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ ENET_VLAN_TAG_FLAGS, 0,
     /* last opt argumnt */ { NULL }, /* --enet-vlan-tag */
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ aEnet_Vlan_TagMustList, NULL,
     /* option proc      */ doOptEnet_Vlan_Tag,
     /* desc, NAME, name */ ENET_VLAN_TAG_DESC, ENET_VLAN_TAG_NAME, ENET_VLAN_TAG_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 23, VALUE_OPT_ENET_VLAN_CFI,
     /* equiv idx, value */ 23, VALUE_OPT_ENET_VLAN_CFI,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ ENET_VLAN_CFI_FLAGS, 0,
     /* last opt argumnt */ { NULL }, /* --enet-vlan-cfi */
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ aEnet_Vlan_CfiMustList, NULL,
     /* option proc      */ doOptEnet_Vlan_Cfi,
     /* desc, NAME, name */ ENET_VLAN_CFI_DESC, ENET_VLAN_CFI_NAME, ENET_VLAN_CFI_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 24, VALUE_OPT_ENET_VLAN_PRI,
     /* equiv idx, value */ 24, VALUE_OPT_ENET_VLAN_PRI,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ ENET_VLAN_PRI_FLAGS, 0,
     /* last opt argumnt */ { NULL }, /* --enet-vlan-pri */
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ aEnet_Vlan_PriMustList, NULL,
     /* option proc      */ doOptEnet_Vlan_Pri,
     /* desc, NAME, name */ ENET_VLAN_PRI_DESC, ENET_VLAN_PRI_NAME, ENET_VLAN_PRI_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 25, VALUE_OPT_HDLC_CONTROL,
     /* equiv idx, value */ 25, VALUE_OPT_HDLC_CONTROL,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ HDLC_CONTROL_FLAGS, 0,
     /* last opt argumnt */ { NULL }, /* --hdlc-control */
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ optionNumericVal,
     /* desc, NAME, name */ HDLC_CONTROL_DESC, HDLC_CONTROL_NAME, HDLC_CONTROL_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 26, VALUE_OPT_HDLC_ADDRESS,
     /* equiv idx, value */ 26, VALUE_OPT_HDLC_ADDRESS,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ HDLC_ADDRESS_FLAGS, 0,
     /* last opt argumnt */ { NULL }, /* --hdlc-address */
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ optionNumericVal,
     /* desc, NAME, name */ HDLC_ADDRESS_DESC, HDLC_ADDRESS_NAME, HDLC_ADDRESS_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 27, VALUE_OPT_USER_DLT,
     /* equiv idx, value */ 27, VALUE_OPT_USER_DLT,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ USER_DLT_FLAGS, 0,
     /* last opt argumnt */ { NULL }, /* --user-dlt */
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ optionNumericVal,
     /* desc, NAME, name */ USER_DLT_DESC, USER_DLT_NAME, USER_DLT_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 28, VALUE_OPT_USER_DLINK,
     /* equiv idx, value */ 28, VALUE_OPT_USER_DLINK,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 2, 0,
     /* opt state flags  */ USER_DLINK_FLAGS, 0,
     /* last opt argumnt */ { NULL }, /* --user-dlink */
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ optionStackArg,
     /* desc, NAME, name */ USER_DLINK_DESC, USER_DLINK_NAME, USER_DLINK_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 29, VALUE_OPT_DBUG,
     /* equiv idx, value */ 29, VALUE_OPT_DBUG,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ DBUG_FLAGS, 0,
     /* last opt argumnt */ { DBUG_DFT_ARG },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ doOptDbug,
     /* desc, NAME, name */ DBUG_DESC, DBUG_NAME, DBUG_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 30, VALUE_OPT_INTF1,
     /* equiv idx, value */ 30, VALUE_OPT_INTF1,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 1, 1, 0,
     /* opt state flags  */ INTF1_FLAGS, 0,
     /* last opt argumnt */ { NULL }, /* --intf1 */
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ NULL,
     /* desc, NAME, name */ INTF1_DESC, INTF1_NAME, INTF1_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 31, VALUE_OPT_INTF2,
     /* equiv idx, value */ 31, VALUE_OPT_INTF2,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ INTF2_FLAGS, 0,
     /* last opt argumnt */ { NULL }, /* --intf2 */
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ NULL,
     /* desc, NAME, name */ INTF2_DESC, INTF2_NAME, INTF2_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 32, VALUE_OPT_UNIDIR,
     /* equiv idx, value */ 32, VALUE_OPT_UNIDIR,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ UNIDIR_FLAGS, 0,
     /* last opt argumnt */ { NULL }, /* --unidir */
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ NULL,
     /* desc, NAME, name */ UNIDIR_DESC, UNIDIR_NAME, UNIDIR_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 33, VALUE_OPT_LISTNICS,
     /* equiv idx, value */ 33, VALUE_OPT_LISTNICS,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ LISTNICS_FLAGS, 0,
     /* last opt argumnt */ { NULL }, /* --listnics */
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ doOptListnics,
     /* desc, NAME, name */ LISTNICS_DESC, LISTNICS_NAME, LISTNICS_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 34, VALUE_OPT_LIMIT,
     /* equiv idx, value */ 34, VALUE_OPT_LIMIT,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ LIMIT_FLAGS, 0,
     /* last opt argumnt */ { LIMIT_DFT_ARG },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ doOptLimit,
     /* desc, NAME, name */ LIMIT_DESC, LIMIT_NAME, LIMIT_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 35, VALUE_OPT_MAC,
     /* equiv idx, value */ 35, VALUE_OPT_MAC,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 2, 0,
     /* opt state flags  */ MAC_FLAGS, 0,
     /* last opt argumnt */ { NULL }, /* --mac */
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ optionStackArg,
     /* desc, NAME, name */ MAC_DESC, MAC_NAME, MAC_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 36, VALUE_OPT_INCLUDE,
     /* equiv idx, value */ 36, VALUE_OPT_INCLUDE,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ INCLUDE_FLAGS, 0,
     /* last opt argumnt */ { NULL }, /* --include */
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, aIncludeCantList,
     /* option proc      */ doOptInclude,
     /* desc, NAME, name */ INCLUDE_DESC, INCLUDE_NAME, INCLUDE_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 37, VALUE_OPT_EXCLUDE,
     /* equiv idx, value */ 37, VALUE_OPT_EXCLUDE,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ EXCLUDE_FLAGS, 0,
     /* last opt argumnt */ { NULL }, /* --exclude */
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, aExcludeCantList,
     /* option proc      */ doOptExclude,
     /* desc, NAME, name */ EXCLUDE_DESC, EXCLUDE_NAME, EXCLUDE_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 38, VALUE_OPT_PID,
     /* equiv idx, value */ 38, VALUE_OPT_PID,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ PID_FLAGS, 0,
     /* last opt argumnt */ { NULL }, /* --pid */
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ doOptPid,
     /* desc, NAME, name */ PID_DESC, PID_NAME, PID_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 39, VALUE_OPT_VERBOSE,
     /* equiv idx, value */ 39, VALUE_OPT_VERBOSE,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ VERBOSE_FLAGS, 0,
     /* last opt argumnt */ { NULL }, /* --verbose */
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ NULL,
     /* desc, NAME, name */ VERBOSE_DESC, VERBOSE_NAME, VERBOSE_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 40, VALUE_OPT_DECODE,
     /* equiv idx, value */ 40, VALUE_OPT_DECODE,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ DECODE_FLAGS, 0,
     /* last opt argumnt */ { NULL }, /* --decode */
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ aDecodeMustList, NULL,
     /* option proc      */ NULL,
     /* desc, NAME, name */ DECODE_DESC, DECODE_NAME, DECODE_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 41, VALUE_OPT_VERSION,
     /* equiv idx, value */ 41, VALUE_OPT_VERSION,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ VERSION_FLAGS, 0,
     /* last opt argumnt */ { NULL }, /* --version */
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ doOptVersion,
     /* desc, NAME, name */ VERSION_DESC, VERSION_NAME, VERSION_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 42, VALUE_OPT_LESS_HELP,
     /* equiv idx, value */ 42, VALUE_OPT_LESS_HELP,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ LESS_HELP_FLAGS, 0,
     /* last opt argumnt */ { NULL }, /* --less-help */
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ doOptLess_Help,
     /* desc, NAME, name */ LESS_HELP_DESC, LESS_HELP_NAME, LESS_HELP_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ INDEX_OPT_HELP, VALUE_OPT_HELP,
     /* equiv idx value  */ NO_EQUIVALENT, VALUE_OPT_HELP,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ OPTST_IMM | OPTST_NO_INIT, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ doUsageOpt,
     /* desc, NAME, name */ HELP_DESC, NULL, HELP_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ INDEX_OPT_MORE_HELP, VALUE_OPT_MORE_HELP,
     /* equiv idx value  */ NO_EQUIVALENT, VALUE_OPT_MORE_HELP,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ MORE_HELP_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL,  NULL,
     /* option proc      */ optionPagedUsage,
     /* desc, NAME, name */ MORE_HELP_DESC, NULL, MORE_HELP_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ INDEX_OPT_SAVE_OPTS, VALUE_OPT_SAVE_OPTS,
     /* equiv idx value  */ NO_EQUIVALENT, VALUE_OPT_SAVE_OPTS,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ OPTST_SET_ARGTYPE(OPARG_TYPE_STRING)
                          | OPTST_ARG_OPTIONAL | OPTST_NO_INIT, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL,  NULL,
     /* option proc      */ NULL,
     /* desc, NAME, name */ SAVE_OPTS_DESC, NULL, SAVE_OPTS_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ INDEX_OPT_LOAD_OPTS, VALUE_OPT_LOAD_OPTS,
     /* equiv idx value  */ NO_EQUIVALENT, VALUE_OPT_LOAD_OPTS,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, NOLIMIT, 0,
     /* opt state flags  */ OPTST_SET_ARGTYPE(OPARG_TYPE_STRING)
			  | OPTST_DISABLE_IMM, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ optionLoadOpt,
     /* desc, NAME, name */ LOAD_OPTS_DESC, LOAD_OPTS_NAME, LOAD_OPTS_name,
     /* disablement strs */ NO_LOAD_OPTS_name, LOAD_OPTS_pfx }
};

tOptDesc * const tcpedit_tcpedit_optDesc_p = optDesc + 0;

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *
 *  Define the tcpbridge Option Environment
 */
#define zPROGNAME       (tcpbridge_opt_strs+3490)
#define zUsageTitle     (tcpbridge_opt_strs+3500)
#define zRcName         (tcpbridge_opt_strs+3631)
static char const * const apzHomeList[2] = {
    tcpbridge_opt_strs+3627,
    NULL };
#define zBugsAddr       (tcpbridge_opt_strs+3644)
#define zExplain        (tcpbridge_opt_strs+3682)
#define zDetail         (tcpbridge_opt_strs+3815)
#define zFullVersion    (NULL)
/* extracted from optcode.tlib near line 350 */

#if defined(ENABLE_NLS)
# define OPTPROC_BASE OPTPROC_TRANSLATE
  static tOptionXlateProc translate_option_strings;
#else
# define OPTPROC_BASE OPTPROC_NONE
# define translate_option_strings NULL
#endif /* ENABLE_NLS */


#define tcpbridge_full_usage (NULL)

#define tcpbridge_short_usage (NULL)

#endif /* not defined __doxygen__ */

/*
 *  Create the static procedure(s) declared above.
 */
/**
 * The callout function that invokes the optionUsage function.
 *
 * @param pOptions the AutoOpts option description structure
 * @param pOptDesc the descriptor for the "help" (usage) option.
 * @noreturn
 */
static void
doUsageOpt(tOptions * pOptions, tOptDesc * pOptDesc)
{
    optionUsage(&tcpbridgeOptions, TCPBRIDGE_EXIT_SUCCESS);
    /* NOTREACHED */
    (void)pOptDesc;
    (void)pOptions;
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
/**
 * Code to handle the mtu option.
 *
 * @param pOptions the tcpbridge options data structure
 * @param pOptDesc the option descriptor for this option.
 */
static void
doOptMtu(tOptions* pOptions, tOptDesc* pOptDesc)
{
    static struct {long rmin, rmax;} const rng[1] = {
        { 1, MAXPACKET } };
    int  ix;

    if (pOptions <= OPTPROC_EMIT_LIMIT)
        goto emit_ranges;
    optionNumericVal(pOptions, pOptDesc);

    for (ix = 0; ix < 1; ix++) {
        if (pOptDesc->optArg.argInt < rng[ix].rmin)
            continue;  /* ranges need not be ordered. */
        if (pOptDesc->optArg.argInt == rng[ix].rmin)
            return;
        if (rng[ix].rmax == LONG_MIN)
            continue;
        if (pOptDesc->optArg.argInt <= rng[ix].rmax)
            return;
    }

    option_usage_fp = stderr;

emit_ranges:
    optionShowRange(pOptions, pOptDesc, (void *)rng, 1);
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
/**
 * Code to handle the tos option.
 *
 * @param pOptions the tcpbridge options data structure
 * @param pOptDesc the option descriptor for this option.
 */
static void
doOptTos(tOptions* pOptions, tOptDesc* pOptDesc)
{
    static struct {long rmin, rmax;} const rng[1] = {
        { 0, 255 } };
    int  ix;

    if (pOptions <= OPTPROC_EMIT_LIMIT)
        goto emit_ranges;
    optionNumericVal(pOptions, pOptDesc);

    for (ix = 0; ix < 1; ix++) {
        if (pOptDesc->optArg.argInt < rng[ix].rmin)
            continue;  /* ranges need not be ordered. */
        if (pOptDesc->optArg.argInt == rng[ix].rmin)
            return;
        if (rng[ix].rmax == LONG_MIN)
            continue;
        if (pOptDesc->optArg.argInt <= rng[ix].rmax)
            return;
    }

    option_usage_fp = stderr;

emit_ranges:
    optionShowRange(pOptions, pOptDesc, (void *)rng, 1);
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
/**
 * Code to handle the tclass option.
 *
 * @param pOptions the tcpbridge options data structure
 * @param pOptDesc the option descriptor for this option.
 */
static void
doOptTclass(tOptions* pOptions, tOptDesc* pOptDesc)
{
    static struct {long rmin, rmax;} const rng[1] = {
        { 0, 255 } };
    int  ix;

    if (pOptions <= OPTPROC_EMIT_LIMIT)
        goto emit_ranges;
    optionNumericVal(pOptions, pOptDesc);

    for (ix = 0; ix < 1; ix++) {
        if (pOptDesc->optArg.argInt < rng[ix].rmin)
            continue;  /* ranges need not be ordered. */
        if (pOptDesc->optArg.argInt == rng[ix].rmin)
            return;
        if (rng[ix].rmax == LONG_MIN)
            continue;
        if (pOptDesc->optArg.argInt <= rng[ix].rmax)
            return;
    }

    option_usage_fp = stderr;

emit_ranges:
    optionShowRange(pOptions, pOptDesc, (void *)rng, 1);
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
/**
 * Code to handle the flowlabel option.
 *
 * @param pOptions the tcpbridge options data structure
 * @param pOptDesc the option descriptor for this option.
 */
static void
doOptFlowlabel(tOptions* pOptions, tOptDesc* pOptDesc)
{
    static struct {long rmin, rmax;} const rng[1] = {
        { 0, 1048575 } };
    int  ix;

    if (pOptions <= OPTPROC_EMIT_LIMIT)
        goto emit_ranges;
    optionNumericVal(pOptions, pOptDesc);

    for (ix = 0; ix < 1; ix++) {
        if (pOptDesc->optArg.argInt < rng[ix].rmin)
            continue;  /* ranges need not be ordered. */
        if (pOptDesc->optArg.argInt == rng[ix].rmin)
            return;
        if (rng[ix].rmax == LONG_MIN)
            continue;
        if (pOptDesc->optArg.argInt <= rng[ix].rmax)
            return;
    }

    option_usage_fp = stderr;

emit_ranges:
    optionShowRange(pOptions, pOptDesc, (void *)rng, 1);
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
/**
 * Code to handle the enet-vlan-tag option.
 *
 * @param pOptions the tcpbridge options data structure
 * @param pOptDesc the option descriptor for this option.
 */
static void
doOptEnet_Vlan_Tag(tOptions* pOptions, tOptDesc* pOptDesc)
{
    static struct {long rmin, rmax;} const rng[1] = {
        { 0, 4095 } };
    int  ix;

    if (pOptions <= OPTPROC_EMIT_LIMIT)
        goto emit_ranges;
    optionNumericVal(pOptions, pOptDesc);

    for (ix = 0; ix < 1; ix++) {
        if (pOptDesc->optArg.argInt < rng[ix].rmin)
            continue;  /* ranges need not be ordered. */
        if (pOptDesc->optArg.argInt == rng[ix].rmin)
            return;
        if (rng[ix].rmax == LONG_MIN)
            continue;
        if (pOptDesc->optArg.argInt <= rng[ix].rmax)
            return;
    }

    option_usage_fp = stderr;

emit_ranges:
    optionShowRange(pOptions, pOptDesc, (void *)rng, 1);
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
/**
 * Code to handle the enet-vlan-cfi option.
 *
 * @param pOptions the tcpbridge options data structure
 * @param pOptDesc the option descriptor for this option.
 */
static void
doOptEnet_Vlan_Cfi(tOptions* pOptions, tOptDesc* pOptDesc)
{
    static struct {long rmin, rmax;} const rng[1] = {
        { 0, 1 } };
    int  ix;

    if (pOptions <= OPTPROC_EMIT_LIMIT)
        goto emit_ranges;
    optionNumericVal(pOptions, pOptDesc);

    for (ix = 0; ix < 1; ix++) {
        if (pOptDesc->optArg.argInt < rng[ix].rmin)
            continue;  /* ranges need not be ordered. */
        if (pOptDesc->optArg.argInt == rng[ix].rmin)
            return;
        if (rng[ix].rmax == LONG_MIN)
            continue;
        if (pOptDesc->optArg.argInt <= rng[ix].rmax)
            return;
    }

    option_usage_fp = stderr;

emit_ranges:
    optionShowRange(pOptions, pOptDesc, (void *)rng, 1);
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
/**
 * Code to handle the enet-vlan-pri option.
 *
 * @param pOptions the tcpbridge options data structure
 * @param pOptDesc the option descriptor for this option.
 */
static void
doOptEnet_Vlan_Pri(tOptions* pOptions, tOptDesc* pOptDesc)
{
    static struct {long rmin, rmax;} const rng[1] = {
        { 0, 7 } };
    int  ix;

    if (pOptions <= OPTPROC_EMIT_LIMIT)
        goto emit_ranges;
    optionNumericVal(pOptions, pOptDesc);

    for (ix = 0; ix < 1; ix++) {
        if (pOptDesc->optArg.argInt < rng[ix].rmin)
            continue;  /* ranges need not be ordered. */
        if (pOptDesc->optArg.argInt == rng[ix].rmin)
            return;
        if (rng[ix].rmax == LONG_MIN)
            continue;
        if (pOptDesc->optArg.argInt <= rng[ix].rmax)
            return;
    }

    option_usage_fp = stderr;

emit_ranges:
    optionShowRange(pOptions, pOptDesc, (void *)rng, 1);
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
/**
 * Code to handle the dbug option, when DEBUG is #define-d.
 *
 * @param pOptions the tcpbridge options data structure
 * @param pOptDesc the option descriptor for this option.
 */
#ifdef DEBUG
static void
doOptDbug(tOptions* pOptions, tOptDesc* pOptDesc)
{
    static struct {long rmin, rmax;} const rng[1] = {
        { 0, 5 } };
    int  ix;

    if (pOptions <= OPTPROC_EMIT_LIMIT)
        goto emit_ranges;
    optionNumericVal(pOptions, pOptDesc);

    for (ix = 0; ix < 1; ix++) {
        if (pOptDesc->optArg.argInt < rng[ix].rmin)
            continue;  /* ranges need not be ordered. */
        if (pOptDesc->optArg.argInt == rng[ix].rmin)
            return;
        if (rng[ix].rmax == LONG_MIN)
            continue;
        if (pOptDesc->optArg.argInt <= rng[ix].rmax)
            return;
    }

    option_usage_fp = stderr;

emit_ranges:
    optionShowRange(pOptions, pOptDesc, (void *)rng, 1);
}
#endif /* defined DEBUG */

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
/**
 * Code to handle the listnics option, when ENABLE_PCAP_FINDALLDEVS is #define-d.
 *
 * @param pOptions the tcpbridge options data structure
 * @param pOptDesc the option descriptor for this option.
 */
#ifdef ENABLE_PCAP_FINDALLDEVS
static void
doOptListnics(tOptions* pOptions, tOptDesc* pOptDesc)
{
    /* extracted from tcpbridge_opts.def, line 172 */

interface_list_t *list = get_interface_list();
list_interfaces(list);
free(list);
exit(0);

    (void)pOptDesc;
    (void)pOptions;
}
#endif /* defined ENABLE_PCAP_FINDALLDEVS */

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
/**
 * Code to handle the limit option.
 *
 * @param pOptions the tcpbridge options data structure
 * @param pOptDesc the option descriptor for this option.
 */
static void
doOptLimit(tOptions* pOptions, tOptDesc* pOptDesc)
{
    static struct {long rmin, rmax;} const rng[1] = {
        { 1, LONG_MAX } };
    int  ix;

    if (pOptions <= OPTPROC_EMIT_LIMIT)
        goto emit_ranges;
    optionNumericVal(pOptions, pOptDesc);

    for (ix = 0; ix < 1; ix++) {
        if (pOptDesc->optArg.argInt < rng[ix].rmin)
            continue;  /* ranges need not be ordered. */
        if (pOptDesc->optArg.argInt == rng[ix].rmin)
            return;
        if (rng[ix].rmax == LONG_MIN)
            continue;
        if (pOptDesc->optArg.argInt <= rng[ix].rmax)
            return;
    }

    option_usage_fp = stderr;

emit_ranges:
    optionShowRange(pOptions, pOptDesc, (void *)rng, 1);
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
/**
 * Code to handle the include option.
 *
 * @param pOptions the tcpbridge options data structure
 * @param pOptDesc the option descriptor for this option.
 */
static void
doOptInclude(tOptions* pOptions, tOptDesc* pOptDesc)
{
    /* extracted from tcpbridge_opts.def, line 229 */

    char *include;

    include = safe_strdup(OPT_ARG(INCLUDE));
    options.xX.mode = xX_MODE_INCLUDE;

    if ((options.xX.mode = parse_xX_str(&options.xX, include, &options.bpf)) == xXError)
        errx(-1, "Unable to parse include/exclude rule: %s", OPT_ARG(INCLUDE));

    free(include);

    (void)pOptDesc;
    (void)pOptions;
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
/**
 * Code to handle the exclude option.
 *
 * @param pOptions the tcpbridge options data structure
 * @param pOptDesc the option descriptor for this option.
 */
static void
doOptExclude(tOptions* pOptions, tOptDesc* pOptDesc)
{
    /* extracted from tcpbridge_opts.def, line 276 */

    char *exclude;

    exclude = safe_strdup(OPT_ARG(EXCLUDE));
    options.xX.mode = xX_MODE_EXCLUDE;

    if ((options.xX.mode = parse_xX_str(&options.xX, exclude, &options.bpf)) == xXError)
        errx(-1, "Unable to parse include/exclude rule: %s", OPT_ARG(EXCLUDE));

    free(exclude);

    (void)pOptDesc;
    (void)pOptions;
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
/**
 * Code to handle the pid option.
 *
 * @param pOptions the tcpbridge options data structure
 * @param pOptDesc the option descriptor for this option.
 */
static void
doOptPid(tOptions* pOptions, tOptDesc* pOptDesc)
{
    /* extracted from tcpbridge_opts.def, line 318 */

    fprintf(stderr, "PID: %d\n", getpid());

    (void)pOptDesc;
    (void)pOptions;
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
/**
 * Code to handle the version option.
 *
 * @param pOptions the tcpbridge options data structure
 * @param pOptDesc the option descriptor for this option.
 */
static void
doOptVersion(tOptions* pOptions, tOptDesc* pOptDesc)
{
    /* extracted from tcpbridge_opts.def, line 363 */

    fprintf(stderr, "tcpbridge version: %s (build %s)", VERSION, git_version());
#ifdef DEBUG
    fprintf(stderr, " (debug)");
#endif
    fprintf(stderr, "\n");
    fprintf(stderr, "Copyright 2013-2014 by Fred Klassen <tcpreplay at appneta dot com> - AppNeta Inc.\n");
    fprintf(stderr, "Copyright 2000-2012 by Aaron Turner <aturner at synfin dot net>\n");
    fprintf(stderr, "The entire Tcpreplay Suite is licensed under the GPLv3\n");
#ifdef HAVE_LIBDNET
    fprintf(stderr, "Compiled against libdnet: %s\n", LIBDNET_VERSION);
#else
    fprintf(stderr, "Not compiled with libdnet.\n");
#endif
#ifdef HAVE_WINPCAP
    fprintf(stderr, "Compiled against winpcap: %s\n", get_pcap_version());
#elif defined HAVE_PF_RING_PCAP
    fprintf(stderr, "Compiled against PF_RING libpcap: %s\n", get_pcap_version());
#else
    fprintf(stderr, "Compiled against libpcap: %s\n", get_pcap_version());
#endif
#ifdef ENABLE_64BITS
    fprintf(stderr, "64 bit packet counters: enabled\n");
#else
    fprintf(stderr, "64 bit packet counters: disabled\n");
#endif
#ifdef ENABLE_VERBOSE
    fprintf(stderr, "Verbose printing via tcpdump: enabled\n");
#else
    fprintf(stderr, "Verbose printing via tcpdump: disabled\n");
#endif
    fprintf(stderr, "Injection method: %s\n", sendpacket_get_method(NULL));

    exit(0);

    (void)pOptDesc;
    (void)pOptions;
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
/**
 * Code to handle the less-help option.
 *
 * @param pOptions the tcpbridge options data structure
 * @param pOptDesc the option descriptor for this option.
 */
static void
doOptLess_Help(tOptions* pOptions, tOptDesc* pOptDesc)
{
    /* extracted from tcpbridge_opts.def, line 408 */

    USAGE(EXIT_FAILURE);

    (void)pOptDesc;
    (void)pOptions;
}
/* extracted from optmain.tlib near line 1146 */

/**
 * The directory containing the data associated with tcpbridge.
 */
#ifndef  PKGDATADIR
# define PKGDATADIR ""
#endif

/**
 * Information about the person or institution that packaged tcpbridge
 * for the current distribution.
 */
#ifndef  WITH_PACKAGER
# define tcpbridge_packager_info NULL
#else
static char const tcpbridge_packager_info[] =
    "Packaged by " WITH_PACKAGER

# ifdef WITH_PACKAGER_VERSION
        " ("WITH_PACKAGER_VERSION")"
# endif

# ifdef WITH_PACKAGER_BUG_REPORTS
    "\nReport tcpbridge bugs to " WITH_PACKAGER_BUG_REPORTS
# endif
    "\n";
#endif
#ifndef __doxygen__

#endif /* __doxygen__ */
/**
 * The option definitions for tcpbridge.  The one structure that
 * binds them all.
 */
tOptions tcpbridgeOptions = {
    OPTIONS_STRUCT_VERSION,
    0, NULL,                    /* original argc + argv    */
    ( OPTPROC_BASE
    + OPTPROC_ERRSTOP
    + OPTPROC_SHORTOPT
    + OPTPROC_LONGOPT
    + OPTPROC_NO_REQ_OPT
    + OPTPROC_NO_ARGS
    + OPTPROC_GNUUSAGE ),
    0, NULL,                    /* current option index, current option */
    NULL,         NULL,         zPROGNAME,
    zRcName,      zCopyright,   zLicenseDescrip,
    zFullVersion, apzHomeList,  zUsageTitle,
    zExplain,     zDetail,      optDesc,
    zBugsAddr,                  /* address to send bugs to */
    NULL, NULL,                 /* extensions/saved state  */
    optionUsage, /* usage procedure */
    translate_option_strings,   /* translation procedure */
    /*
     *  Indexes to special options
     */
    { INDEX_OPT_MORE_HELP, /* more-help option index */
      INDEX_OPT_SAVE_OPTS, /* save option index */
      NO_EQUIVALENT, /* '-#' option index */
      9 /* index of default opt */
    },
    47 /* full option count */, 43 /* user option count */,
    tcpbridge_full_usage, tcpbridge_short_usage,
    NULL, NULL,
    PKGDATADIR, tcpbridge_packager_info
};

#if ENABLE_NLS
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <autoopts/usage-txt.h>

static char* AO_gettext(char const* pz);
static void  coerce_it(void** s);

/**
 * AutoGen specific wrapper function for gettext.
 * It relies on the macro _() to convert from English to the target
 * language, then strdup-duplicates the result string.
 *
 * @param[in] pz the input text used as a lookup key.
 * @returns the translated text (if there is one),
 *   or the original text (if not).
 */
static char *
AO_gettext(char const* pz)
{
    char* pzRes;
    if (pz == NULL)
        return NULL;
    pzRes = _(pz);
    if (pzRes == pz)
        return pzRes;
    pzRes = strdup(pzRes);
    if (pzRes == NULL) {
        fputs(_("No memory for duping translated strings\n"), stderr);
        exit(TCPBRIDGE_EXIT_FAILURE);
    }
    return pzRes;
}

static void coerce_it(void** s) { *s = AO_gettext(*s);
}

/**
 * Translate all the translatable strings in the tcpbridgeOptions
 * structure defined above.  This is done only once.
 */
static void
translate_option_strings(void)
{
    tOptions * const pOpt = &tcpbridgeOptions;

    /*
     *  Guard against re-translation.  It won't work.  The strings will have
     *  been changed by the first pass through this code.  One shot only.
     */
    if (option_usage_text.field_ct != 0) {
        /*
         *  Do the translations.  The first pointer follows the field count
         *  field.  The field count field is the size of a pointer.
         */
        tOptDesc * pOD = pOpt->pOptDesc;
        char **    ppz = (char**)(void*)&(option_usage_text);
        int        ix  = option_usage_text.field_ct;

        do {
            ppz++;
            *ppz = AO_gettext(*ppz);
        } while (--ix > 0);

        coerce_it((void*)&(pOpt->pzCopyright));
        coerce_it((void*)&(pOpt->pzCopyNotice));
        coerce_it((void*)&(pOpt->pzFullVersion));
        coerce_it((void*)&(pOpt->pzUsageTitle));
        coerce_it((void*)&(pOpt->pzExplain));
        coerce_it((void*)&(pOpt->pzDetail));
        coerce_it((void*)&(pOpt->pzPackager));
        option_usage_text.field_ct = 0;

        for (ix = pOpt->optCt; ix > 0; ix--, pOD++)
            coerce_it((void*)&(pOD->pzText));
    }

    if ((pOpt->fOptSet & OPTPROC_NXLAT_OPT_CFG) == 0) {
        tOptDesc * pOD = pOpt->pOptDesc;
        int        ix;

        for (ix = pOpt->optCt; ix > 0; ix--, pOD++) {
            coerce_it((void*)&(pOD->pz_Name));
            coerce_it((void*)&(pOD->pz_DisableName));
            coerce_it((void*)&(pOD->pz_DisablePfx));
        }
        /* prevent re-translation */
        tcpbridgeOptions.fOptSet |= OPTPROC_NXLAT_OPT_CFG | OPTPROC_NXLAT_OPT;
    }
}

#endif /* ENABLE_NLS */

#ifdef  __cplusplus
}
#endif
/* tcpbridge_opts.c ends here */
